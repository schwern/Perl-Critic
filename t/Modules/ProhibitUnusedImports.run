## name Pass with no import list.
## failures 0
## cut

use Foo;

#------------------------------------------------------------------------------

## name Pass with empty import list.
## failures 0
## cut

use Foo ();

#------------------------------------------------------------------------------

## name Pass with no import list and minimum version.
## failures 0
## cut

use Foo 1.3;

#------------------------------------------------------------------------------

## name Pass with empty import list and minimum version.
## failures 0
## cut

use Foo 1.3 ();

#------------------------------------------------------------------------------

## name Pass with empty quoted word list and minimum version.
## failures 0
## cut

use Foo 1.3 qw//;

#------------------------------------------------------------------------------

## name Pass with bare variable.
## failures 0
## cut

use Foo $bar;
use Ping %pong;

#------------------------------------------------------------------------------

## name Pass with interpolated variable.
## failures 0
## cut

use This "$that";
use Some qq/$other @thing/;

#------------------------------------------------------------------------------

## name Pass with used variable.
## failures 0
## cut

use Foo $bar;

$bar = 'why, HELLO there!';

#------------------------------------------------------------------------------

## name Pass Test::More.
## failures 0
## cut

use Test::More tests => 47;

#------------------------------------------------------------------------------

## name Simple failure of individually listed variables.
## failures 3
## cut

use A '$B';
use C q<@D>;
use E qw< %F >;

#------------------------------------------------------------------------------

## name Simple failure of list.
## failures 3
## cut

use A ('$B', q<@C>, qw< %D >)

#------------------------------------------------------------------------------

## name Simple failure with vars.
## failures 2
## cut

use vars qw< $foo @bar >;

#------------------------------------------------------------------------------

## name Simple failure with English (one of the reasons Elliot wrote this policy).
## failures 1
## cut

use English qw< $EVAL_ERROR -no_match_vars >;

#------------------------------------------------------------------------------

## name Don't let use of a hash slice make it seem like an array is used.
## failures 1
## cut

use Foo qw< @BAR >;

@BAR{ qw< a b > } = (1, 2);

#------------------------------------------------------------------------------

## name Don't let use of subscript make it seem like the array isn't used.
## failures 0
## cut

use Foo qw< @BAR >;

$BAR[0] = 1;

#------------------------------------------------------------------------------

## name Don't let use of array index make it seem like the array isn't used.
## failures 0
## cut

use Foo qw< @BAR >;

$x = $#BAR;

#------------------------------------------------------------------------------

## name Don't let use of index make it seem like the hash isn't used.
## failures 0
## cut

use Foo qw< %BAR >;

$BAR{a} = 1;

#------------------------------------------------------------------------------

## name Don't let use of a hash slice make it seem like the hash isn't used.
## failures 0
## cut

use Foo qw< %BAR >;

@BAR{ qw< a b > } = (1, 2);

#------------------------------------------------------------------------------

## name Pass for use of scalar in double quoted string.
## failures 0
## cut

use Foo qw< $BAR >;

"$BAR";

#------------------------------------------------------------------------------

## name Failure for non-use of scalar in double quoted string by escaping the $.
## failures 1
## cut

use Foo qw< $BAR >;

"\$BAR";

#------------------------------------------------------------------------------

## name Pass for use of scalar in interpolated string.
## failures 0
## cut

use Foo qw< $BAR >;

qq/$BAR/;

#------------------------------------------------------------------------------

## name Failure for non-use of scalar in interpolated string by escaping the $.
## failures 1
## cut

use Foo qw< $BAR >;

qq<\$BAR>;

#------------------------------------------------------------------------------

## name Pass for use of scalar in interpolated heredoc.
## failures 0
## cut

use Foo qw< $BAR >;

$x = <<"END_HERE";
$BAR
END_HERE

#------------------------------------------------------------------------------

## name Failure for non-use of scalar in interpolated heredoc by escaping the $.
## failures 1
## cut

use Foo qw< $BAR >;

$x = <<"END_HERE";
\$BAR
END_HERE

#------------------------------------------------------------------------------

## name Failure for non-use of scalar in non-interpolated heredoc.
## failures 1
## cut

use Foo qw< $BAR >;

$x = <<'END_HERE';
$BAR
END_HERE

#------------------------------------------------------------------------------

## name Pass for use of scalar in regular expression.
## failures 0
## cut

use Foo qw< $BAR >;

m/$BAR/;

#------------------------------------------------------------------------------

## name Pass for use of scalar in regular expression reference.
## failures 0
## cut

use Foo qw< $BAR >;

qr/$BAR/;

#------------------------------------------------------------------------------

## name Pass for use of scalar in substitution pattern.
## failures 0
## cut

use Foo qw< $BAR >;

s/$BAR/baz/;

#------------------------------------------------------------------------------

## name Pass for use of scalar in substitution value.
## failures 0
## cut

use Foo qw< $BAR >;

s/baz/$BAR/;

#------------------------------------------------------------------------------

## name Pass for use of scalar in back quotes.
## failures 0
## cut

use Foo qw< $BAR >;

`$BAR`;

#------------------------------------------------------------------------------

## name Pass for use of scalar in qx.
## failures 0
## cut

use Foo qw< $BAR >;

qx/$BAR/;

#------------------------------------------------------------------------------

## name ignored_modules
## failures 0
## parms { ignored_modules => 'A' }
## cut

use A ('$B', q<@C>, qw< %D >)

#------------------------------------------------------------------------------

## name Don't fail globs yet.
## failures 0
## cut

use A '*B';

#------------------------------------------------------------------------------

## name Don't fail subroutines without sigils yet.
## failures 0
## cut

use A 'some_subroutine';

#------------------------------------------------------------------------------

## name Don't fail subroutines with sigils yet.
## failures 0
## cut

use A '&some_subroutine';

#------------------------------------------------------------------------------

## name Find failures when there are multiple packages in a single module.
## failures 1
## TODO We don't split on packages yet in any policy.
## cut

package Foo;

use A '$B';

package Bar;

$B = 27;

#------------------------------------------------------------------------------

##############################################################################
# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 78
#   indent-tabs-mode: nil
#   c-indentation-style: bsd
# End:
# ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
