##################################################################
#      $URL: http://perlcritic.tigris.org/svn/perlcritic/trunk/Perl-Critic/lib/Perl/Critic/Policy/BuiltinFunctions/RequireBlockMap.pm $
#     $Date: 2005-12-13 16:46:24 -0800 (Tue, 13 Dec 2005) $
#   $Author: thaljef $
# $Revision: 121 $
##################################################################

=pod

=head1 NAME

Developer - How to make new Perl::Critic::Policy modules

=head1 DESCRIPTION

This document describes how to make new L<Perl::Critic::Policy>
modules by dissecting an existing Policy.  In this case, we'll be
looking at L<Perl::Critic::Policy::BuiltinFunctions::RequireBlockGrep>
which is relatively simple, but demonstrates all the ingredients that
are found in every Policy module.

After reading this, you should probably also look at the documentation
for L<PPI> to better understand how you can navigate and manipulate
the parse tree.

=head1 BACKGROUND

In a nutshell, L<PPI> transforms a file of Perl source code into a
Document Object Model.  Each token in the document is represented by
various PPI object (for example, L<PPI::Token::Operator>,
L<PPI::Token::Word>).  Likewise, these object are organized into a
heirarchy of various types of structures (for example,
L<PPI::Structure::Statement>, L<PPI::Structure::Subroutine>).  The root
node of the heirarchy is the L<PPI::Document>.

L<Perl::Critic> traverses each node in the Document, it invokes each
of the Policies at the appropriate node.  The Policy inspects the
node, looks at the surrounding nodes, or does whatever it wants.  If
the Policy decides that that a coding standard has been violated, it
creates and returns one or more L<Perl::Critic::Violation> objects.
If there are no violations, then the Policy returns nothing.

The Policy module we will look at here is F<RequireBlockGrep.pm>.
The goal of this Policy is to enforce that every call to C<grep> uses
a block for the first argument and not an expression.  The reasons for
this Policy are discussed in detail in "Perl Best Practices."

  grep { /foo/ } @list;  #This is ok
  grep /foo/, @list;     #This is not ok

=head1 EXAMPLE

So now lets see how this all works.  First, your Policy module needs
to have a name.  Perl::Critic will automatically discover all modules
that are in the C<Perl::Critic::Policy> namespace.  Also, we've
adopted the convention of grouping Policies into directories according
to the table of contents in Conway's book "Perl Best Practices."
Since the goal of this policy is to enforce the use of block arguments
to C<grep>, we'll call it F<RequireBlockGrep.pm>.

  package Perl::Critic::Policy::BuiltinFunctions::RequireBlockGrep;

Next, we set some pragmas and load the modules that we'll need.  All
Policy modules inherit from the L<Perl::Critic::Policy> class, which
provides no-op implementations of the basic methods.  Our job is to
override these methods to make them do something useful.

Technically, C<use strict> and C<use warnings> are optional, but they
are necessary to make Perl::Critic self-compliant.  And we don't
want Perl::Critic to be a hypocrite, now do we?

  use strict;
  use warnings;
  use Perl::Critic::Utils;
  use Perl::Critic::Violation;
  use base 'Perl::Critic::Policy';

This is a pretty standard way to declare a version number for you
module, and it's also required for self-compliance.  But the
C<ProhibitStringyEval> policy doesn't approve of using C<eval> in this
manner, so we attach the "##no critic" comments to tell Perl::Critic
to overlook this line of code.

  our $VERSION = '0.13_01';
  $VERSION = eval $VERSION;    ## no critic


Next, we'll declare a description and explanation for this Policy.
The description is always just a string that basically says "this is
what's wrong."  The explanation can be either a string with further
details, or a reference to an array of integers that correspond to
page numbers in the "Perl Best Practices" book.

  my $desc = q{Expression form of 'grep'};
  my $expl = [169];

Here we define the C<default_severity()> method, which should return a
scalar value indicating the severity of violating this Policy.
Severity values range from 1 to 5, where 5 is the "most severe."  In
general, level 5 is reserved for things that are frequently misused
and/or cause bugs.  Level 1 is for things that are highly subject and
purely cosmetic.  The L<Perl::Critic::Utils> package exports several
severity constants that you can use here.

  sub default_severity  { return $SEVERITY_HIGH }

Next we define which types of PPI objects this Policy should be
invoked on.  The applies_to() method returns a list of PPI package
names.  As Perl::Critic traverses the document, it will call the
C<violates()> method from this module whenever it encouters one of the
PPI types that are given here.  In this case, we just want to test
calls to C<grep>.  Since the token "grep" is a L<PPI::Token::Word>, we
return that name from the C<applies_to()> method.

  sub applies_to { return 'PPI::Token::Word' }


Now comes the interesting part.  The C<violates()> method does all the
work.  It is always called with 2 arguments: a reference to the
current node or "element" that Perl::Critic is traversing, and a
reference to the entire PPI document. [And since this is an object
method, there will be an additional argument that is a reference to
this object (C<$self>), but you alreday knew that!]

  sub violates {
      my ( $self, $elem, $doc ) = @_;

Next, we do some tests to make sure we have the right "type" of
element.  We know it will be a L<PPI::Token::Word> because that's what
we declared back in the C<applies_to()> method.  However, we didn't
specify exactly which "word" we were looking for.  Evaluating a PPI
element in a string context returns the literal form of the code.  So
we make sure that this PPI::Token::Word is, in fact, "grep".  If it's
not, then we dont' need to bother examining it.

    return if !($elem eq 'grep');

The C<PPI::Token::Word> class is also used for barewords and methods
called on object references.  It is possible for someone to declare a
bareword hashkey as C<%hash = ( grep => 'foo' )>.  We don't want to
test those types of elements beacause they don't represent function
calls to C<grep>.  So we use some handy utility functions from
L<Perl::Critic::Utils> to make sure that this "grep" is actually in
the right context.

    return if is_method_call($elem);
    return if is_hash_key($elem);

Now that we know this element is a function call to C<grep>, we can
look at the nearby elements to see what kind of arguments are being
passed to it.  Every PPI element is linked to its siblings, parent,
and children (if it has any).  Since those siblings could just be
whitespace, we use the C<snext_sibling()> to get the next code-sibling
(the 's' in 'snext' stands for 'significant').

    my $sib = $elem->snext_sibling() || return;

In Perl, the parenthesis around argument lists are usually optional,
and PPI packs the elements into a L<PPI::Structure::List> ojbect when
parens are used.  So if the sibling is a PPI::Structure::List, we pull
out the first (significant) child of that list.  This child will be
the first argument to C<grep>.  If parens were not used, then the
sibling itself is the first argument.

    my $arg = $sib->isa('PPI::Structure::List') ? $sib->schild(0) : $sib;

Finally, we now have a reference to the first argument to C<grep>.  If
that argument is a block (i.e. something in curly braces), then it will
be a L<PPI::Structure::Block>, in which case our Policy is satisfied and
we just return nothing.

    return if !$arg || $arg->isa('PPI::Structure::Block');

But if it is not a L<PPI::Strucutre::Block>, then we know that this
call to C<grep> must be using the expression form, and that violates
our Policy.  So we create and return a new L<Perl::Critic::Violation>
object, passing in the description, explanation, location, and
severity of this violation.  And that's all there is to it!

    return Perl::Critic::Violation->new( $desc,
                                         $expl,
                                         $elem->location(),
                                         $self->get_severity(), );
  }

  1;

One last thing -- When you import Perl::Critic::Violation, it extracts
the DESCRIPTION section from the POD in your Policy module.  That text
can displayed in the diagnostic output when the Violations objects are
string-ified.  So please include a DESCRIPTION section in the POD for
your Policy.  It should succintcly describe the behavior and
motivation for your Policy and include a few examples of both good and
bad code.

  =pod

  =head1 NAME

  Perl::Critic::Policy::BuiltinFunctions::RequireBlockGrep

  =head1 DESCRIPTION

  The expression form of C<grep> and C<map> is awkward and hard to read.
  Use the block forms instead.

    @matches = grep   /pattern/,   @list;        #not ok
    @matches = grep { /pattern/ }  @list;        #ok

    @mapped = map   transform($_),   @list;      #not ok
    @mapped = map { transform($_) }  @list;      #ok

  =cut

=head1 AUTHOR

Jeffrey Ryan Thalhammer <thaljef@cpan.org>

=head1 COPYRIGHT

Copyright (c) 2005 Jeffrey Ryan Thalhammer.  All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.  The full text of this license
can be found in the LICENSE file included with this module.

=cut
