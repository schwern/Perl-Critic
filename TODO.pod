# best viewed via "perldoc TODO.pod"

=pod

=for stopwords LHS RHS REFACTORINGS FH SVN stopwords

=head1 NAME

TODO - Things for Perl::Critic developers to do

=head1 SOURCE

    #######################################################################
    #      $URL$
    #     $Date$
    #   $Author$
    # $Revision$
    #######################################################################

=head1 NEW FEATURES

=over 4

=item * Report Safari sections in addition to book page numbers.

=item * Report some statistics on the violations and the source code.

e.g. Number of violations of each policy/severity.  Total lines of code,
number of subroutines, average number of statements/operators per sub.

=back

=head1 BUGS/LIMITATIONS

=over 4

=item * Invalid policy names in .perlcriticrc do not cause any warnings.

=item * Invalid parameters in .perlcriticrc do not cause any warnings.

=item * Modules::RequireVersionVar

Doesn't enforce three-part versions

=item * NamingConventions::ProhibitAmbiguousNames

Don't allow compound names with forbidden words, like "last_record".
Allow forbidden words in RHS of variable declarations

=item * Subroutines::ProtectPrivateSubs

Doesn't forbid C<< $pkg->_foo() >> because it can't tell the
difference between that and C<< $self->_foo() >>

=item * ErrorHandling::RequireCarping

This should not complain about using warn or die if it's not in a
function.

Also, if the error string ends with a "\n", then the line number
and package information is not shown, so it doesn't matter if you
use carp/confess or not.  For example:

    my $fh;
    if ( !open( $fh, '<', $filename ) ) {
        warn "ack: $filename: $!\n";
        return;
    }

I just want to print a warning and move on.  The location is irrelevant.

=back

=head1 OTHER PBP POLICIES THAT SEEM FEASIBLE TO IMPLEMENT

=over 4


=item * ControlStructures::ProhibitComplexMappings (p113)

Base this on RequireSimpleSortBlock.  Make number of statements configurable

=item * ValuesAndExpressions::ProhibitCommaSeparatedStatements (p68)

=item * ValuesAndExpressions::RequireListParens (p71)

=item * ValuesAndExpressions::ProhibitScalarGrep (p71)

Look for grep in a scalar context and recommend any() instead.
Perhaps we need to distinguish cases like:
   $count += grep {qr/foo/} @list;

=item * Variables::RequireLocalizedPunctuationVars (p81)

=item * Variables::ProhibitTopicChangeInListFunction (p114)

=item * Documentation::PodSpelling (p148)

Base it on Pod::Spell or Test::Spelling. Add a "=for stopwords"
section for words to skip, as per Pod::Spell.

=item * Subroutines::RequireArgUnpacking (p178)

Ensure that the first child of a sub is PPI::Statement::Variable
(unless the sub has N or fewer statements, where N defaults to 1.

=item * Subroutines::ProhibitManyArgs (p182)

If first L<PPI::Statement::Variable> is a list C<my>, and @_ is used,
make sure it's fewer than N elements.  Otherwise make sure there are
less than N L<PPI::Statement::Variable>s in a row at begin which
shift.

=item * InputOutput::RequireErrorChecking (p208)

Forbid open, print, close in void context, unless "use Fatal" is in
effect.

=item * InputOutput::RequireBriefOpen (p209)

Make sure there's a close within N statements of an open, both with
same lexical FH

=item * InputOutput::ProhibitJoinedReadline (p213)

=item * InputOutput::ProhibitExplicitStdin (p216)

=item * Miscellanea::ProhibitObnoxiousComments

Forbid excessive hash marks e.g. "#### This is a loud comment ####".
Make the obnoxious pattern configurable

=item * RegularExpressions::RequireBracesForMultiline (p242)

=item * RegularExpressions::ProhibitUnusualDelimiters (p246)

=item * RegularExpressions::ProhibitEscapedMetacharacters (p247)

=item * RegularExpressions::ProhibitEnumeratedClasses (p248)

This will be avoided for ASCII-only code

=item * RegularExpressions::ProhibitUnusedCapture (p252)

Look for LHS of regexp or use of C<$1>, C<$2>, ... before next
regexp

=item * RegularExpressions::ProhibitComplexRegexps (p261)

If regexp is longer than N characters/lines, require it be split
into C<qr//> pieces.

=item * RegularExpressions::ProhibitSingleCharAlternation (p265)

Not sure if this is easy or hard.  Need to look at what PPI emits
for regexps.  Make an exception for qr/ [ ] /x.

=item * RegularExpressions::ProhibitFixedStringMatches (p271)

Can't be C<qr/\s*\\A\s*\((?:\?:)?(?:\s*\w+\s*\|)*\s*\w+\s*\)\s*\\z/>
or C<qr/\s*\\A\s*\w+\s*\\z/>

=item * TestingAndDebugging::ProhibitProlongedStrictureOverride (p443)

This conflicts with TestingAndDebugging::ProhibitNoStrict

=back

=head1 NON-PBP POLICIES WANTED

=over 4

=item AllProgramsNeedShebangs

Anything that is a program should have a shebang line.  This includes .t files.

=item * BuiltInFunctions::RequireConstantSprintfFormat

=item * BuiltInFunctions::RequireConstantUnpackFormat

L<http://home.earthlink.net/~josh.jore/new-warnings/slides/slide1.html>

=item * ControlStructures::ProhibitIncludeViaDo

Forbid C<do "foo.pl">.  Not sure about this policy name.

=item * CodeLayout::ProhibitNonASCII

Definitely low severity!  Only looks at code, not comments or POD

=item * CodeLayout::RequireUTF8

All characters must be valid UTF-8.  Note that typical ASCII Perl code
is a valid UTF8 subset.

=item * Miscellanea::RequireMinimumPerlVersion

Every module should have something like C<use 5.6.0>

=item * Miscellanea::Prohibit5006isms

Keep the code 5.005 compatible. Low severity

=item * Variables::ProhibitUseVars

Disallow C<use vars qw(...)> and require C<our $foo> instead.  This
contradicts Miscellanea::Prohibit5006isms.  Maybe verify C<use 5.6>
before applying this policy.  Low severity.

=item * VariablesAndExpressions::ProhibitQuotedHashKeys

Forbid quotes around hash keys, unless they are really needed.  This
is against what Damian says.  Suggested by Adam Kennedy.  Low
severity.

=item * Miscellanea::B::Lint

Create a compatibility layer for the L<B::Lint> code analyzer.  Make
it very clear that this runs code and thus is a security hole.

=item * CodeLayout::ProhibitFunctionalNew

Good: C<< Foo::Bar->new >>, Bad: C<< new Foo::Bar >>

=item * VariablesAndExpressions::RequireConstantVersion (low severity)

=item * VariablesAndExpressions::ProhibitComplexVersion (medium severity)

L<http://rt.cpan.org/Ticket/Display.html?id=20439>

=item * Variables::ProhibitPerl4PackageNames

Forbid old-school package names like Foo'Bar'Baz.  This should also
apply to any variables or subroutines that get declared/called.

=item * CodeLayout::RequireEditorSettings

Files must have something like the following in them for Emacs and Vi:

  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  # End:
  # vim: expandtab shiftwidth=4:

=over 4

=item Emacs file variables

L<http://www.gnu.org/software/emacs/manual/html_node/File-Variables.html>

In emacs, this is called "File Variables".  There are two syntaxes:
C<-*- ... -*-> (single-line) and C<Local Variables:\n...\nEnd:>
(multi-line).  Both syntaxes allow leading and trailing text on the
line.

The single-line syntax must be used on the first line of the file to
be recognized.

The multi-line syntax must be used "in the last page" at the end of
the file.  As of Emacs21, this is hard-coded to be the last 3000 bytes
of the file (in the hack-local-variables function in files.el).  In
this syntax, each line must begin and end with the same prefix/suffix
pair.  That pair is defined by the text before and after the "Local
Variables:" string.

=item Vim modelines

In vim, this is called "modelines" and should match the following
pattern:

  [text]{white}{vi:|vim:|ex:}[white]se[t] {options}:[text]

The vim modeline must be within N lines of the top or bottom of the
file.  That N is user-settable, but defaults to 5.  To learn more type
":help modelines" in vim.

=item Kate modelines

I also discovered that Kate supports per-file modelines:

L<http://kate-editor.org/article/katepart_modelines>

=back

=item * Documentation::RequireSynopsis

=item * Documentation::RequireLicense

These are simplified versions of Documentation::RequirePodSections.

=item * Miscellaneous::ProhibitBoilerplate

Complain about copy-and-paste code or docs from h2xs, Module::Starter::*,
etc.

Here's a non-PPI implementation:
L<http://search.cpan.org/src/JJORE/Carp-Clan-5.8/t/04boilerplate.t>

=item * ValuesAndExpressions::ProhibitHereDocs

=item * ValuesAndExpressions::ProhibitLongStrings

Low severity.

Both of these attempt to address problems with code layout and appearance.
Large blocks of inline text can disrupt the readability of code.  Instead, the
text should be external, in __DATA__, or simply declared in separate functions
at the end of the module.

Exceptions: if the only code in a sub is a return of a long string, allow it.
If there is a C<use Inline::> at the top of the module, allow HereDocs.

L<http://rt.cpan.org/Ticket/Display.html?id=20714>

=item * CodeLayout::ProhibitTrailingSpaces

Forbid [ \t] before \n.  This is a subset of RequireTidyCode.

L<http://rt.cpan.org/Ticket/Display.html?id=20714>

=back

=head1 REFACTORINGS and ENHANCEMENTS

=over 4

=item * Alias -verbose to -format option in Test::P::C.

Give it same functionality as the -verbose option in `perlcritic`

=item * Enhance P::C::critique() to accept file names, directories, or code strings (as refs)

Just like F<bin/perlcritic> does now.

=item * Add C<-cache> flag to F<bin/perlcritic>

If enabled, this turns on L<PPI::Cache>:

    require PPI::Cache;
    my $cache_path = "/tmp/test-perl-critic-cache-$ENV{USER}";
    mkdir $cache_path, oct 700 if (! -d $cache_path);
    PPI::Cache->import(path => $cache_path);

(see F<t/40_criticize.t> for a more robust implementation)

=item * File::RequirePortableName

No spaces, punctuation, etc.

=back

=head1 PPI BUGS

We're waiting on the following bugs to get fixed in a CPAN release of PPI:

=over 4

=item literal()

ValuesAndExpressions::RequireNumberSeparators uses a stringy eval to
numify.  Current PPI SVN has code for the
PPI::Token::Number->literal() method which numifies from source.  When
we depend on a PPI version higher than 1.118, the _to_number()
function in that policy can be removed in favor of literal().

=item Newlines

PPI does not preserve newlines.  That makes
CodeLayout::RequireConsistentNewlines impossible to implement under PPI.  For
now, it's implemented by pulling the source out of the file and skipping PPI.

It's unlikely that PPI will support mixde newlines anytime soon.

=item Anonymous constructors in lists

The following parses wrong in PPI v1.118.  A PPI fix is in progress.

  bless( {} );

When this is fixed, uncomment a few tests in t/20_policies_classhierarchies.t

=item Operators

ValuesAndExpressions::ProhibitMismatchedOperators has two workarounds
for PPI bugs with parsing operators.  Many of these bugs have been
fixed in PPI, so it would be good to check if those workarounds are
still needed.

=back

=cut
