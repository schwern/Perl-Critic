# best viewed via "perldoc TODO.pod"

=pod

=for stopwords LHS RHS REFACTORINGS FH SVN stopwords

=head1 NAME

TODO - Things for Perl::Critic developers to do

=head1 SOURCE

    #######################################################################
    #      $URL$
    #     $Date$
    #   $Author$
    # $Revision$
    #######################################################################

=head1 NEW FEATURES

=over 4

=item * Report Safari sections in addition to book page numbers.

=item * Report some statistics on the violations and the source code.

e.g. Number of violations of each policy/severity.  Total lines of code,
number of subroutines, average number of statements/operators per sub.

=back

=head1 BUGS/LIMITATIONS

=over 4

=item * Invalid policy names in .perlcriticrc do not cause any warnings.

=item * Invalid parameters in .perlcriticrc do not cause any warnings.

=item * Modules::RequireVersionVar

Doesn't enforce three-part versions

=item * NamingConventions::ProhibitAmbiguousNames

Don't allow compound names with forbidden words, like "last_record".
Allow forbidden words in RHS of variable declarations

=item * Subroutines::ProtectPrivateSubs

Doesn't forbid C<< $pkg->_foo() >> because it can't tell the
difference between that and C<< $self->_foo() >>

=item * ErrorHandling::RequireCarping

This should not complain about using warn or die if it's not in a
function, or if it's not in a non-main:: package.

Also, if the error string ends with a "\n", then the line number
and package information is not shown, so it doesn't matter if you
use carp/confess or not.  For example:

    my $fh;
    if ( !open( $fh, '<', $filename ) ) {
        warn "ack: $filename: $!\n";
        return;
    }

I just want to print a warning and move on.  The location is irrelevant.

=item * Variables::ProhibitPackageVars

Allow a way to specify packages that ARE OK to have the package
vars for.  For example, File::Find requires you to access package
vars.  There is no other way.  Data::Dumper's package vars are the
most common way to set parameters for it.

=item * RegularExpressions::ProhibitCaptureWithoutTest

Allow this construct:

    for ( ... ) {
        next unless /(....)/;
        if ( $1 ) {
            ....
        }
    }

Right now, P::C thinks that the C<$1> isn't legal to use because it's
"outside" of the match.  The thing is, we can only get to the C<if>
if the regex matched.
    while ( $str =~ /(expression)/ ) 

=item * Module::Pluggable

Module::Pluggable has the unpleasant feature of silently ignoring
compilation errors in loaded modules.  This creates hard-to-diagnose
bugs.  Look for a workaround to make Module::Pluggable die() when
syntax errors happen, or replace it entirely.

=back

=head1 OTHER PBP POLICIES THAT SEEM FEASIBLE TO IMPLEMENT

=over 4

=item * ControlStructures::ProhibitComplexMappings (p113)

Base this on RequireSimpleSortBlock.  Make number of statements configurable

=item * ValuesAndExpressions::ProhibitCommaSeparatedStatements (p68)

=item * ValuesAndExpressions::RequireListParens (p71)

=item * ValuesAndExpressions::ProhibitScalarGrep (p71)

Look for C<grep> in a scalar context and recommend C<any()> instead.
Perhaps we need to distinguish cases like:

    $count += grep {qr/foo/} @list;

OTOH, this assumes that the common use of scalar grep is to check
for existence.  I'm not sure that's the case.

=item * Variables::RequireLocalizedPunctuationVars (p81)

=item * ControlStructures::ProhibitMutatingListFunctions (p114)

Partially implemented (see SKIP tests in t/20_policies_variables.t.  Needs documentation.

This should be renamed to ControlStructures::ProhibitMutatingListFunctions

=item * Documentation::PodSpelling (p148)

Base it on Pod::Spell or Test::Spelling. Add a "=for stopwords"
section for words to skip, as per Pod::Spell.

=item * Subroutines::RequireArgUnpacking (p178)

Ensure that the first child of a sub is PPI::Statement::Variable
(unless the sub has N or fewer statements, where N defaults to 1.

=item * Subroutines::ProhibitManyArgs (p182)

If first L<PPI::Statement::Variable> is a list C<my>, and @_ is used,
make sure it's fewer than N elements.  Otherwise make sure there are
less than N L<PPI::Statement::Variable>s in a row at begin which
shift.

=item * InputOutput::RequireErrorChecking (p208)

Forbid open, print, close in void context, unless "use Fatal" is in
effect.  Allow an exception for close and print.

=item * InputOutput::RequireBriefOpen (p209)

Make sure there's a close within N statements of an open, both with
same lexical FH

=item * InputOutput::ProhibitJoinedReadline (p213)

=item * InputOutput::ProhibitExplicitStdin (p216)

If you're reading from STDIN, chances are you're really wanting to
read from the magic filehandle.

=item * Miscellanea::ProhibitObnoxiousComments

Forbid excessive hash marks e.g. "#### This is a loud comment ####".
Make the obnoxious pattern configurable

=item * RegularExpressions::RequireBracesForMultiline (p242)

=item * RegularExpressions::ProhibitUnusualDelimiters (p246)

=item * RegularExpressions::ProhibitEscapedMetacharacters (p247)

=item * RegularExpressions::ProhibitEnumeratedClasses (p248)

This will be avoided for ASCII-only code.

=item * RegularExpressions::ProhibitUnusedCapture (p252)

Look for LHS of regexp or use of C<$1>, C<$2>, ... before next
regexp.

=item * RegularExpressions::ProhibitComplexRegexps (p261)

If regexp is longer than N characters/lines, require it be split
into C<qr//> pieces.

=item * RegularExpressions::ProhibitSingleCharAlternation (p265)

Not sure if this is easy or hard.  Need to look at what PPI emits
for regexps.  Make an exception for qr/ [ ] /x.

=item * RegularExpressions::ProhibitFixedStringMatches (p271)

Can't be C<qr/\s*\\A\s*\((?:\?:)?(?:\s*\w+\s*\|)*\s*\w+\s*\)\s*\\z/>
or C<qr/\s*\\A\s*\w+\s*\\z/>

=back

=head1 NON-PBP POLICIES WANTED

=over 4

=item * TBD::VariableNotUsed

Detect a variable that has a value assigned to it, but never used.

=item * TBD::AllProgramsNeedShebangs

Anything that is a program should have a shebang line.  This includes .t files.

=item * BuiltInFunctions::RequireConstantSprintfFormat

=item * BuiltInFunctions::RequireConstantUnpackFormat

L<http://home.earthlink.net/~josh.jore/new-warnings/slides/slide1.html>

=item * ControlStructures::ProhibitIncludeViaDo

Forbid C<do "foo.pl">.  Not sure about this policy name.

=item * CodeLayout::ProhibitNonASCII

Definitely low severity!  Only looks at code, not comments or POD

=item * CodeLayout::RequireUTF8

All characters must be valid UTF-8.  Note that typical ASCII Perl code
is a valid UTF8 subset.

=item * Miscellanea::RequireMinimumPerlVersion

Every module should have something like C<use 5.6.0>

=item * Miscellanea::Prohibit5006isms

Keep the code 5.005 compatible. Low severity

=item * Variables::ProhibitUseVars

Disallow C<use vars qw(...)> and require C<our $foo> instead.  This
contradicts Miscellanea::Prohibit5006isms.  Maybe verify C<use 5.6>
before applying this policy.  Low severity.

=item * VariablesAndExpressions::ProhibitQuotedHashKeys

Forbid quotes around hash keys, unless they are really needed.  This
is against what Damian says.  Suggested by Adam Kennedy.  Low
severity.

=item * Miscellanea::B::Lint

Create a compatibility layer for the L<B::Lint> code analyzer.  Make
it very clear that this runs code and thus is a security hole.

=item * CodeLayout::ProhibitFunctionalNew

Good: C<< Foo::Bar->new >>, Bad: C<< new Foo::Bar >>

=item * VariablesAndExpressions::RequireConstantVersion (low severity)

=item * VariablesAndExpressions::ProhibitComplexVersion (medium severity)

L<http://rt.cpan.org/Ticket/Display.html?id=20439>

=item * Variables::ProhibitPerl4PackageNames

Forbid old-school package names like Foo'Bar'Baz.  This should also
apply to any variables or subroutines that get declared/called.

=item * Editor::RequireEmacsFileVariables

=item * Editor::RequireViModelines

Files must have something like the following in them for Emacs and Vi:

  # Local Variables:
  #   mode: cperl
  #   cperl-indent-level: 4
  #   fill-column: 78
  # End:
  # vim: expandtab shiftwidth=4:

=over 4

=item Emacs file variables

Implemented!  Currently just tests for the existence of "-*- ... -*-"
or "Local Variables: ... End:".  This should eventually take a
perlcriticrc option to specify the exact set of variables.

=item Vim modelines

In vim, this is called "modelines" and should match the following
pattern (taken from Vim docs):

  [text]{white}{vi:|vim:|ex:}[white]se[t] {options}:[text]
  [text]{white}{vi:|vim:|ex:}[white]{options}

Roughly translated to regexp:

  ($options) = m/^ (?:\N*\S)? [ \t]+ (?:vi|vim|ex): [ \t]+ set? [ \t]+ (\N+): \N* $/xms;
  ($options) = m/^ (?:\N*\S)? [ \t]+ (?:vi|vim|ex): [ \t]+ (\N+) $/xms;

Watch out for escaped colons!!

The vim modeline must be within N lines of the top or bottom of the
file.  That N is user-settable, but defaults to 5.  To learn more type
":help modelines" in vim.

=item Kate modelines

I also discovered that Kate supports per-file modelines:

L<http://kate-editor.org/article/katepart_modelines>

=back

=item * Documentation::RequireSynopsis

=item * Documentation::RequireLicense

These are simplified versions of Documentation::RequirePodSections.

=item * Miscellaneous::ProhibitBoilerplate

Complain about copy-and-paste code or docs from h2xs, Module::Starter::*,
etc.

Here's a non-PPI implementation:
L<http://search.cpan.org/src/JJORE/Carp-Clan-5.8/t/04boilerplate.t>

=item * ValuesAndExpressions::ProhibitHereDocs

=item * ValuesAndExpressions::ProhibitLongStrings

Low severity.

Both of these attempt to address problems with code layout and appearance.
Large blocks of inline text can disrupt the readability of code.  Instead, the
text should be external, in __DATA__, or simply declared in separate functions
at the end of the module.

Exceptions: if the only code in a sub is a return of a long string, allow it.
If there is a C<use Inline::> at the top of the module, allow HereDocs.

L<http://rt.cpan.org/Ticket/Display.html?id=20714>

=item * CodeLayout::ProhibitTrailingSpaces

Forbid [ \t] before \n.  This is a subset of RequireTidyCode.

L<http://rt.cpan.org/Ticket/Display.html?id=20714>

=back

=head1 REFACTORINGS and ENHANCEMENTS

=over 4

=item * Alias -verbose to -format option in Test::P::C.

Give it same functionality as the -verbose option in `perlcritic`

=item * Enhance P::C::critique() to accept file names, directories, or code strings (as refs)

Just like F<bin/perlcritic> does now.

=item * Add C<-cache> flag to F<bin/perlcritic>

If enabled, this turns on L<PPI::Cache>:

    require PPI::Cache;
    my $cache_path = "/tmp/test-perl-critic-cache-$ENV{USER}";
    mkdir $cache_path, oct 700 if (! -d $cache_path);
    PPI::Cache->import(path => $cache_path);

(see F<t/40_criticize.t> for a more robust implementation)

=item * File::RequirePortableName

No spaces, punctuation, etc.

=back

=head1 PPI BUGS

We're waiting on the following bugs to get fixed in a CPAN release of PPI:

=over 4

=item literal()

ValuesAndExpressions::RequireNumberSeparators uses a stringy eval to
numify.  Current PPI SVN has code for the
PPI::Token::Number->literal() method which numifies from source.  When
we depend on a PPI version higher than 1.118, the _to_number()
function in that policy can be removed in favor of literal().

=item Newlines

PPI does not preserve newlines.  That makes
CodeLayout::RequireConsistentNewlines impossible to implement under PPI.  For
now, it's implemented by pulling the source out of the file and skipping PPI.

It's unlikely that PPI will support mixde newlines anytime soon.

=item Anonymous constructors in lists

The following parses wrong in PPI v1.118.  A PPI fix is in progress.

  bless( {} );

When this is fixed, uncomment a few tests in t/20_policies_classhierarchies.t

=item Operators

ValuesAndExpressions::ProhibitMismatchedOperators has two workarounds
for PPI bugs with parsing operators.  Many of these bugs have been
fixed in PPI, so it would be good to check if those workarounds are
still needed.

=item Hash constructors being parsed as blocks

ValuesAndExpressions::ProhibitMagicNumbers has a performance optimization that
can't be done because it can't tell whether a block is really a block or not.

When fixed, uncomment the lines in
_element_is_in_an_include_or_readonly_statement().

=back

=cut
