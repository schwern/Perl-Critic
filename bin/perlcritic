#!/usr/bin/perl

##############################################################################
#      $URL$
#     $Date$
#   $Author$
# $Revision$
##############################################################################

package main;

use 5.006001;
use strict;
use warnings;

use English qw< -no_match_vars >;
use Readonly;

use Getopt::Long qw< GetOptions >;
use List::Util qw< first >;
use Pod::Usage qw< pod2usage >;

use Perl::Critic::Exception::Parse ();
use Perl::Critic::Utils qw<
    :characters :severities policy_short_name
    $DEFAULT_VERBOSITY $DEFAULT_VERBOSITY_WITH_FILE_NAME
>;
use Perl::Critic::Violation qw<>;

#-----------------------------------------------------------------------------

our $VERSION = '1.093_02';

Readonly::Scalar my $DEFAULT_VIOLATIONS_FOR_TOP => 20;

Readonly::Scalar my $EXIT_SUCCESS           => 0;
Readonly::Scalar my $EXIT_NO_FILES          => 1;
Readonly::Scalar my $EXIT_HAD_VIOLATIONS    => 2;
Readonly::Scalar my $EXIT_HAD_FILE_PROBLEMS => 3;

#-----------------------------------------------------------------------------
# Begin script.  Don't run when loaded as a library

my @files = ();
my $critic = undef;
my $output = \*STDOUT;

# This %ENV check is to allow perlcritic to function when bundled under PAR,
# which invokes this program not as the top stack frame. -- rjbs, 2008-08-11
exit run() if not caller or $ENV{PAR_0};

#-----------------------------------------------------------------------------
# Begin subroutines

sub out {
    my @lines = @_;
    return print {$output} @lines;
}

#-----------------------------------------------------------------------------

sub run {
    my %options    = get_options();
    @files         = get_input(@ARGV);

    my ($violations, $had_error_in_file) = critique(\%options, @files);

    return $EXIT_HAD_FILE_PROBLEMS  if $had_error_in_file;
    return $EXIT_NO_FILES           if not defined $violations;
    return $EXIT_HAD_VIOLATIONS     if $violations;

    return $EXIT_SUCCESS;
}

#-----------------------------------------------------------------------------

sub get_options {

    my %opts = _parse_command_line();
    _dispatch_special_requests( %opts );
    _validate_options( %opts );

    # Convert severity shortcut options.  If multiple shortcuts
    # are given, the lowest one wins.  If an explicit --severity
    # option has been given, then the shortcuts are ignored. The
    # @SEVERITY_NAMES variable is exported by Perl::Critic::Utils.
    $opts{-severity} ||= first { exists $opts{"-$_"} } @SEVERITY_NAMES;
    $opts{-severity} ||= first { exists $opts{"-$_"} } ($SEVERITY_LOWEST ..  $SEVERITY_HIGHEST);


    # If --top is specified, default the severity level to 1, unless an
    # explicit severity is defined.  This provides us flexibility to
    # report top-offenders across just some or all of the severity levels.
    # We also default the --top count to twenty if none is given
    if ( exists $opts{-top} ) {
        $opts{-severity} ||= 1;
        $opts{-top} ||= $DEFAULT_VIOLATIONS_FOR_TOP;
    }

    #Override profile, if --noprofile is specified
    if ( exists $opts{-noprofile} ) {
        $opts{-profile} = $EMPTY;
    }

    return %opts;
}

#-----------------------------------------------------------------------------

sub _parse_command_line {
    my %opts;
    my @opt_specs = _get_option_specification();
    Getopt::Long::Configure('no_ignore_case');
    GetOptions( \%opts, @opt_specs ) || pod2usage();           #Exits

    # I've adopted the convention of using key-value pairs for
    # arguments to most functions.  And to increase legibility,
    # I have also adopted the familiar command-line practice
    # of denoting argument names with a leading dash (-).
    my %dashed_opts = map { ( "-$_" => $opts{$_} ) } keys %opts;
    return %dashed_opts;
}

#-----------------------------------------------------------------------------

sub _dispatch_special_requests {
    my (%opts) = @_;
    if ( $opts{-help}            ) { pod2usage( -verbose => 0 )  }  #Exits
    if ( $opts{-options}         ) { pod2usage( -verbose => 1 )  }  #Exits
    if ( $opts{-man}             ) { pod2usage( -verbose => 2 )  }  #Exits
    if ( $opts{-version}         ) { out "$VERSION\n"; exit 0; }  #Exits
    if ( $opts{-list}            ) { render_policy_listing();    }  #Exits
    if ( $opts{'-list-themes'}   ) { render_theme_listing();     }  #Exits
    if ( $opts{'-profile-proto'} ) { render_profile_prototype(); }  #Exits
    if ( $opts{-doc}             ) { policy_docs( %opts );  }  #Exits
    return 1;
}

#-----------------------------------------------------------------------------

sub _validate_options {
    my (%opts) = @_;
    my $msg = $EMPTY;


    if ( $opts{-noprofile} && $opts{-profile} ) {
        $msg .= qq{Warning: Cannot use -noprofile with -profile option.\n};
    }

    if ( $opts{-verbose} && $opts{-verbose} !~ m{(?: \d+ | %[mfFlcedrpPs] )}xms) {
        $msg .= qq<Warning: --verbose arg "$opts{-verbose}" looks odd.  >;
        $msg .= qq<Perhaps you meant to say "--verbose 3 $opts{-verbose}."\n>;
    }

    if ( exists $opts{-top} && $opts{-top} < 0 ) {
        $msg .= qq<Warning: --top argument "$opts{-top}" is negative.  >;
        $msg .= qq<Perhaps you meant to say "$opts{-top} --top".\n>;
    }

    if (
            exists $opts{-severity}
        &&  (
                    $opts{-severity} < $SEVERITY_LOWEST
                ||  $opts{-severity} > $SEVERITY_HIGHEST
            )
    ) {
        $msg .= qq<Warning: --severity arg "$opts{-severity}" out of range.  >;
        $msg .= qq<Severities range from "$SEVERITY_LOWEST" (lowest) to >;
        $msg .= qq<"$SEVERITY_HIGHEST" (highest).\n>;
    }


    if ( $msg ) {
        pod2usage( -exitstatus => 1, -message => $msg, -verbose => 0); #Exits
    }


    return 1;
}

#-----------------------------------------------------------------------------

sub get_input {

    my @args = @_;

    if ( !@args || (@args == 1 && $args[0] eq q{-}) )  {

        # Reading code from STDIN.  All the code is slurped into
        # a string.  PPI will barf if the string is just whitespace.
        my $code_string = do { local $RS = undef; <STDIN> };

        # Notice if STDIN was closed (pipe error, etc)
        if ( ! defined $code_string ) {
            $code_string = $EMPTY;
        }

        $code_string =~ m{ \S+ }xms || die qq{Nothing to critique.\n};
        return \$code_string;    #Convert to SCALAR ref for PPI
    }
    else {

        # Test to make sure all the specified files or directories
        # actually exist.  If any one of them is bogus, then die.
        if ( my $nonexistent = first { ! -e $_ } @args ) {
            my $msg = qq{No such file or directory: '$nonexistent'};
            pod2usage( -exitstatus => 1, -message => $msg, -verbose => 0);
        }

        # Reading code from files or dirs.  If argument is a file,
        # then we process it as-is (even though it may not actually
        # be Perl code).  If argument is a directory, recursively
        # search the directory for files that look like Perl code.
        return map { -d $_ ? Perl::Critic::Utils::all_perl_files($_) : $_ } @args;
    }
}

#------------------------------------------------------------------------------

sub critique {

    my ( $opts_ref, @files_to_critique ) = @_;
    @files_to_critique || die "No perl files were found.\n";

    # Perl::Critic has lots of dependencies, so loading is delayed
    # until it is really needed.  This hack reduces startup time for
    # doing other things like getting the version number or dumping
    # the man page. Arguably, those things are pretty rare, but hey,
    # why not save a few seconds if you can.

    require Perl::Critic;
    $critic = Perl::Critic->new( %{$opts_ref} );
    $critic->policies() || die "No policies selected.\n";

    set_up_pager($critic->config()->pager());

    my $number_of_violations = undef;
    my $had_error_in_file = 0;

    for my $file (@files_to_critique) {

        eval {
            my @violations = $critic->critique($file);
            $number_of_violations += scalar @violations;

            if (not $opts_ref->{'-statistics-only'}) {
                render_report( $file, $opts_ref, @violations )
            }
            1;
        }
        or do {
            if ( my $exception = Perl::Critic::Exception::Parse->caught() ) {
                $had_error_in_file = 1;
                warn qq<Problem while critiquing "$file": $EVAL_ERROR\n>;
            }
            elsif ($EVAL_ERROR) {
                # P::C::Exception::Fatal includes the stack trace in its
                # stringification.
                die qq<Fatal error while critiquing "$file": $EVAL_ERROR\n>;
            }
            else {
                die qq<Fatal error while critiquing "$file". Unfortunately, >,
                    q<$@/$EVAL_ERROR >, ## no critic (RequireInterpolationOfMetachars)
                    qq<is empty, so the reason can't be shown.\n>;
            }
        }
    }

    if ( $opts_ref->{-statistics} or $opts_ref->{'-statistics-only'} ) {
        my $stats = $critic->statistics();
        report_statistics( $opts_ref, $stats );
    }

    return $number_of_violations, $had_error_in_file;
}

#------------------------------------------------------------------------------

sub render_report {

    my ( $file, $opts_ref, @violations ) = @_;

    # Only report the number of violations, if asked.
    my $number_of_violations = scalar @violations;
    if( $opts_ref->{-count} ){
        ref $file || out "$file: ";
        out "$number_of_violations\n";
        return $number_of_violations;
    }

    # Hail all-clear unless we should shut up.
    if( !@violations && !$opts_ref->{-quiet} ) {
        ref $file || out "$file ";
        out "source OK\n";
        return 0;
    }

    # Otherwise, format and print violations
    my $verbosity = $critic->config->verbose();
    # $verbosity can be numeric or string, so use "eq" for comparison;
    $verbosity =
        ($verbosity eq $DEFAULT_VERBOSITY && @files > 1)
            ? $DEFAULT_VERBOSITY_WITH_FILE_NAME
            : $verbosity;
    my $fmt = Perl::Critic::Utils::verbosity_to_format( $verbosity );
    if (not -f $file) { $fmt =~ s< \%[fF] ><STDIN>xms; } #HACK!
    Perl::Critic::Violation::set_format( $fmt );

    my $color = $critic->config->color();
    out $color ? _colorize_by_severity(@violations) : @violations;

    return $number_of_violations;
}

#-----------------------------------------------------------------------------

sub set_up_pager {
    my ($pager_command) = @_;
    return if not $pager_command;
    return if not _at_tty();

    open my $pager, q<|->, $pager_command  ## no critic (InputOutput::RequireBriefOpen)
        or die qq<Unable to pipe to pager "$pager_command": $ERRNO\n>;

    $output = $pager;

    return;
}

#-----------------------------------------------------------------------------

sub report_statistics {
    my ($opts_ref, $statistics) = @_;

    if (
            not $opts_ref->{'-statistics-only'}
        and (
                $statistics->total_violations()
            or  not $opts_ref->{-quiet} and $statistics->modules()
        )
    ) {
        out "\n"; # There's prior output that we want to separate from.
    }

    out _commaify($statistics->modules()), " files.\n";
    out _commaify($statistics->subs()), " subroutines/methods.\n";
    out _commaify($statistics->statements_other_than_subs()), " statements.\n";
    out _commaify($statistics->lines()), " lines.\n";

    my $average_sub_mccabe = $statistics->average_sub_mccabe();
    if (defined $average_sub_mccabe) {
        out sprintf
            "\nAverage McCabe score of subroutines was %.2f.\n",
            $average_sub_mccabe;
    }

    out "\n";

    out _commaify($statistics->total_violations()), " violations.\n";

    my $violations_per_file = $statistics->violations_per_file();
    if (defined $violations_per_file) {
        out sprintf
            "Violations per file was %.3f.\n",
            $violations_per_file;
    }
    my $violations_per_statement = $statistics->violations_per_statement();
    if (defined $violations_per_statement) {
        out sprintf
            "Violations per statement was %.3f.\n",
            $violations_per_statement;
    }
    my $violations_per_line = $statistics->violations_per_line_of_code();
    if (defined $violations_per_line) {
        out sprintf
            "Violations per line of code was %.3f.\n",
            $violations_per_line;
    }

    if ( $statistics->total_violations() ) {
        out "\n";

        my %severity_violations = %{ $statistics->violations_by_severity() };
        foreach my $severity ( reverse sort keys %severity_violations ) {
            out
                _commaify($severity_violations{$severity}),
                " severity $severity violations.\n";
        }

        out "\n";

        my %policy_violations = %{ $statistics->violations_by_policy() };
        foreach my $policy ( sort keys %policy_violations ) {
            out
                _commaify($policy_violations{$policy}),
                ' violations of ',
                policy_short_name($policy),
                ".\n";
        }
    }

    return;
}

#-----------------------------------------------------------------------------

# Only works for integers.
sub _commaify {
    my ( $number ) = @_;

    while ($number =~ s/ \A ( [-+]? \d+ ) ( \d{3} ) /$1,$2/xms) {
        # nothing
    }

    return $number;
}

#-----------------------------------------------------------------------------

sub _get_option_specification {

    return qw(
        5 4 3 2 1
        Safari
        version
        brutal
        count|C
        cruel
        doc=s
        exclude=s@
        force!
        gentle
        harsh
        help|?|H
        include=s@
        list
        list-themes
        man
        color|colour!
        noprofile
        only!
        options
        pager=s
        profile=s
        profile-proto
        quiet
        severity=i
        single-policy|s=s
        stern
        statistics!
        statistics-only!
        profile-strictness=s
        theme=s
        top:i
        verbose=s
        warn-about-useless-no-critic!
    );
}

#-----------------------------------------------------------------------------

sub _colorize_by_severity {
    my (@violations) = @_;
    return @violations if _this_is_windows();
    return @violations if not eval { require Term::ANSIColor };

    my %color_of = (
        $SEVERITY_HIGHEST => 'bold red',
        $SEVERITY_HIGH    => 'magenta',
    );
    return map { _colorize( "$_", $color_of{$_->severity()} ) } @violations;

}

#-----------------------------------------------------------------------------

sub _colorize {
    my ($string, $color) = @_;
    return $string if not defined $color;
    return  Term::ANSIColor::colored( $string, $color );
}

#-----------------------------------------------------------------------------

sub _this_is_windows {
    return 1 if $OSNAME =~ m/MSWin32/xms;
    return 0;
}

#-----------------------------------------------------------------------------

sub _at_tty {
    return -t STDOUT; ## no critic (ProhibitInteractiveTest);
}

#-----------------------------------------------------------------------------

sub render_policy_listing {

    require Perl::Critic::PolicyListing;
    require Perl::Critic;

    my %pc_params = (-profile => $EMPTY, -severity => $SEVERITY_LOWEST);
    my @policies = Perl::Critic->new( %pc_params )->policies();
    my $listing = Perl::Critic::PolicyListing->new( -policies => \@policies );
    out $listing;
    exit 0;
}

#-----------------------------------------------------------------------------

sub render_theme_listing {
    require Perl::Critic::ThemeListing;
    require Perl::Critic;

    my %pc_params = (-profile => $EMPTY, -severity => $SEVERITY_LOWEST);
    my @policies = Perl::Critic->new( %pc_params )->policies();
    my $listing = Perl::Critic::ThemeListing->new( -policies => \@policies );
    out $listing;
    exit 0;
}

#-----------------------------------------------------------------------------

sub render_profile_prototype {

    require Perl::Critic::ProfilePrototype;
    require Perl::Critic;

    my %pc_params = (-profile => $EMPTY, -severity => $SEVERITY_LOWEST);
    my @policies = Perl::Critic->new( %pc_params )->policies();
    my $prototype = Perl::Critic::ProfilePrototype->new( -policies => \@policies );
    out $prototype;
    exit 0;
}

#-----------------------------------------------------------------------------

sub policy_docs {

    my (%opts) = @_;
    my $pattern = delete $opts{-doc};

    require Perl::Critic;
    $critic = Perl::Critic->new(%opts);
    set_up_pager($critic->config()->pager());

    require Perl::Critic::PolicyFactory;
    my @site_policies  = Perl::Critic::PolicyFactory->site_policy_names();
    my @matching_policies  = grep { $_ =~ m/$pattern/ixms } @site_policies;

    # "-T" means don't send to pager
    my @perldoc_output = map {`perldoc -T $_`} @matching_policies;  ## no critic (ProhibitBacktick)
    out @perldoc_output;

    exit 0;
}

1;

__END__

#-----------------------------------------------------------------------------

=pod

=for stopwords DGR INI-style vim-fu minibuffer -noprofile API
-profileproto -profile-proto ben Jore formatter Peshak pbp Komodo
screenshots tty emacs gVIM plugin Perlish templating ActiveState

=head1 NAME

C<perlcritic> - Command-line interface to critique Perl source.


=head1 SYNOPSIS

  perlcritic [-12345 | --brutal | --cruel | --harsh | --stern | --gentle]
             [--severity number | name] [--profile file | --noprofile]
             [--top [ number ]] [--theme expression] [--include pattern]
             [--exclude pattern] [{-s | --single-policy} pattern]
             [--only | --noonly] [--profile-strictness {warn|fatal|quiet}]
             [--force | --noforce] [--statistics] [--statistics-only]
             [--count | -C] [--verbose {number | format}]
             [--color | --nocolor] [--pager pager] [--quiet]
             {FILE | DIRECTORY | STDIN}

  perlcritic --profile-proto

  perlcritic { --list | --list-themes | --doc pattern [...] }

  perlcritic { --help | --options | --man | --version }


=head1 DESCRIPTION

C<perlcritic> is a Perl source code analyzer.  It is the executable
front-end to the L<Perl::Critic|Perl::Critic> engine, which attempts
to identify awkward, hard to read, error-prone, or unconventional
constructs in your code.  Most of the rules are based on Damian
Conway's book B<Perl Best Practices>.  However, C<perlcritic> is
B<not> limited to enforcing PBP, and it will even support rules that
contradict Conway.  All rules can easily be configured or disabled to
your liking.

This documentation only covers how to drive this command.  For all
other information, including how to persistently configure this
command so that you don't have to say so much on the command-line, see
the documentation for L<Perl::Critic|Perl::Critic> itself.


=head1 USAGE EXAMPLES

Before getting into all the gory details, here are some basic usage
examples to help get you started.

    # Report only most severe violations (severity = 5)
    perlcritic YourModule.pm

    # Same as above, but read input from STDIN
    perlcritic

    # Recursively process all Perl files beneath directory
    perlcritic /some/directory

    # Report slightly less severe violations too (severity >= 4)
    perlcritic -4 YourModule.pm

    # Same as above, but using named severity level
    perlcritic --stern YourModule.pm

    # Report all violations, regardless of severity (severity >= 1)
    perlcritic -1 YourModule.pm

    # Same as above, but using named severity level
    perlcritic --brutal YourModule.pm

    # Report only violations of things from "Perl Best Practices"
    perlcritic --theme pbp YourModule.pm

    # Report top 20 most severe violations (severity >= 1)
    perlcritic --top YourModule.pm

    # Report additional violations of Policies that match m/variables/xms
    perlcritic --include variables YourModule.pm

    # Use defaults from somewhere other than ~/.perlcriticrc
    perlcriticrc --profile project/specific/perlcriticrc YourModule.pm


=head1 ARGUMENTS

The arguments are paths to the files you wish to analyze.  You may
specify multiple files.  If an argument is a directory, C<perlcritic>
will analyze all Perl files below the directory.  If no arguments are
specified, then input is read from STDIN.


=head1 OPTIONS

Option names can be abbreviated to uniqueness and can be stated with
singe or double dashes, and option values can be separated from the
option name by a space or '=' (as with L<Getopt::Long|Getopt::Long>).
Option names are also case-sensitive.

=over

=item C<--profile FILE>

Directs C<perlcritic> to use a profile named by FILE rather than
looking for the default F<.perlcriticrc> file in the current directory
or your home directory.  See L<Perl::Critic/"CONFIGURATION"> for more
information.

=item C<--noprofile>

Directs C<perlcritic> not to load any configuration file, thus
reverting to the default configuration for all Policies.

=item C<--severity N>

Directs C<perlcritic> to only apply Policies with a severity greater
than C<N>.  Severity values are integers ranging from 1 (least severe)
to 5 (most severe).  The default is 5.  For a given C<--profile>,
decreasing the C<--severity> will usually produce more violations.
You can set the default value for this option in your F<.perlcriticrc>
file.  You can also redefine the C<severity> for any Policy in your
F<.perlcriticrc> file.  See L<"CONFIGURATION"> for more information.

=item C<-5 | -4 | -3 | -2 | -1>

These are numeric shortcuts for setting the C<--severity> option.  For
example, C<"-4"> is equivalent to C<"--severity 4">.  If multiple
shortcuts are specified, then the most restrictive one wins.  If an
explicit C<--severity> option is also given, then all shortcut options
are silently ignored.  NOTE: Be careful not to put one of the number
severity shortcut options immediately after the C<--top> flag or
C<perlcritic> will interpret it as the number of violations to report.

=item C<--severity NAME>

If it is difficult for you to remember whether severity "5" is the
most or least restrictive level, then you can use one of these named
values:

    SEVERITY NAME   ...is equivalent to...   SEVERITY NUMBER
    --------------------------------------------------------
    --severity gentle                           --severity 5
    --severity stern                            --severity 4
    --severity harsh                            --severity 3
    --severity cruel                            --severity 2
    --severity brutal                           --severity 1

=item C<--gentle | --stern | --harsh | --cruel | --brutal>

These are named shortcuts for setting the C<--severity> option.  For
example, C<"--cruel"> is equivalent to C<"--severity 2">.  If multiple
shortcuts are specified, then the most restrictive one wins.  If an
explicit C<--severity> option is also given, then all shortcut options
are silently ignored.

=item C<--theme RULE>

Directs C<perlcritic> to apply only Policies with themes that satisfy
the C<RULE>.  Themes are arbitrary names for groups of related
policies.  You can combine theme names with boolean operators to
create an arbitrarily complex C<RULE>.  For example, the following
would apply only Policies that have a 'bugs' AND 'pbp' theme:

    $> perlcritic --theme='bugs && pbp' MyModule.pm

Unless the C<--severity> option is explicitly given, setting
C<--theme> silently causes the C<--severity> to be set to 1.  You can
set the default value for this option in your F<.perlcriticrc> file.
See L<Perl::Critic/"POLICY THEMES"> for more information about themes.

=item C<--include PATTERN>

Directs C<perlcritic> to apply additional Policies that match the
regex C</PATTERN/imx>.  Use this option to temporarily override your
profile and/or the severity settings at the command-line.  For
example:

    perlcritic --include=layout my_file.pl

This would cause C<perlcritic> to apply all the C<CodeLayout::*>
policies even if they have a severity level that is less than the
default level of 5, or have been disabled in your F<.perlcriticrc>
file.  You can specify multiple C<--include> options and you can use
it in conjunction with the C<--exclude> option.  Note that
C<--exclude> takes precedence over C<--include> when a Policy matches
both patterns.  You can set the default value for this option in your
F<.perlcriticrc> file.

=item C<--exclude PATTERN>

Directs C<perlcritic> to not apply any Policy that matches the regex
C</PATTERN/imx>.  Use this option to temporarily override your profile
and/or the severity settings at the command-line.  For example:

    perlcritic --exclude=strict my_file.pl

This would cause C<perlcritic> to not apply the C<RequireUseStrict>
and C<ProhibitNoStrict> Policies even though they have the highest
severity level.  You can specify multiple C<--exclude> options and you
can use it in conjunction with the C<--include> option.  Note that
C<--exclude> takes precedence over C<--include> when a Policy matches
both patterns.  You can set the default value for this option in your
F<.perlcriticrc> file.

=item C<--single-policy PATTERN>

=item C<-s PATTERN>

Directs C<perlcritic> to apply just one Policy module matching the
regex C</PATTERN/ixms>, and exclude all other Policies.  This option
has precedence over the C<--severity>, C<--theme>, C<--include>,
C<--exclude>, and C<--only> options.  For example:

    perlcritic --single-policy=nowarnings my_file.pl

This would cause C<perlcritic> to apply just the C<ProhibitNoWarnings>
Policy, regardless of the severity level setting.  No other Policies
would be applied.

This is equivalent to what one might intend by...

    perlcritic --exclude=. --include=nowarnings my_file.pl

... but this won't work because the C<--exclude> option overrides the
C<--include> option.

The equivalent of this option can be accomplished by creating a custom
profile containing only the desired policy and then running...

    perlcritic --profile=customprofile --only my_file.pl

=item C<--top [ N ]>

Directs C<perlcritic> to report only the top C<N> Policy violations in
each file, ranked by their severity.  If C<N> is not specified, it
defaults to 20.  If the C<--severity> option (or one of the shortcuts)
is not explicitly given, the C<--top> option implies that the minimum
severity level is "1" (i.e. "brutal"). Users can redefine the severity
for any Policy in their F<.perlcriticrc> file.  See L<"CONFIGURATION">
for more information.  You can set the default value for this option
in your F<.perlcriticrc> file.  NOTE: Be careful not to put one of the
severity shortcut options immediately after the C<--top> flag or
C<perlcritic> will interpret it as the number of violations to report.

=item C<--force>

Directs C<perlcritic> to ignore the magical C<"## no critic">
pseudo-pragmas in the source code. See L<"BENDING THE RULES"> for more
information.  You can set the default value for this option in your
F<.perlcriticrc> file.

=item C<--statistics>

Causes several statistics about the code being scanned and the
violations found to be reported after any other output.

=item C<--statistics-only>

Like the C<--statistics> option, but suppresses normal output and only
shows the statistics.

=item C<--verbose N | FORMAT>

Sets the verbosity level or format for reporting violations.  If given
a number (C<N>), C<perlcritic> reports violations using one of the
predefined formats described below.  If given a string (C<FORMAT>), it
is interpreted to be an actual format specification.  If the
C<--verbose> option is not specified, it defaults to either 4 or 5,
depending on whether multiple files were given as arguments to
C<perlcritic>.  You can set the default value for this option in your
F<.perlcriticrc> file.

    Verbosity     Format Specification
    -----------   -------------------------------------------------------
     1            "%f:%l:%c:%m\n",
     2            "%f: (%l:%c) %m\n",
     3            "%m at %f line %l\n",
     4            "%m at line %l, column %c.  %e.  (Severity: %s)\n",
     5            "%f: %m at line %l, column %c.  %e.  (Severity: %s)\n",
     6            "%m at line %l, near '%r'.  (Severity: %s)\n",
     7            "%f: %m at line %l near '%r'.  (Severity: %s)\n",
     8            "[%p] %m at line %l, column %c.  (Severity: %s)\n",
     9            "[%p] %m at line %l, near '%r'.  (Severity: %s)\n",
    10            "%m at line %l, column %c.\n  %p (Severity: %s)\n%d\n",
    11            "%m at line %l, near '%r'.\n  %p (Severity: %s)\n%d\n"

Formats are a combination of literal and escape characters similar to
the way C<sprintf> works.  See L<String::Format|String::Format> for a
full explanation of the formatting capabilities.  Valid escape
characters are:

    Escape    Meaning
    -------   ------------------------------------------------------------
    %c        Column number where the violation occurred
    %d        Full diagnostic discussion of the violation
    %e        Explanation of violation or page numbers in PBP
    %F        Just the name of the file where the violation occurred.
    %f        Path to the file where the violation occurred.
    %l        Line number where the violation occurred
    %m        Brief description of the violation
    %P        Full name of the Policy module that created the violation
    %p        Name of the Policy without the Perl::Critic::Policy:: prefix
    %r        The string of source code that caused the violation
    %s        The severity level of the violation

The purpose of these formats is to provide some compatibility with
text editors that have an interface for parsing certain kinds of
input. See L<"EDITOR INTEGRATION"> for more information about that.

=item C<--list>

Displays a condensed listing of all the
L<Perl::Critic::Policy|Perl::Critic::Policy> modules that are found on
this machine.  For each Policy, the name, default severity and default
themes are shown.

=item C<--list-themes>

Displays a list of all the themes of the
L<Perl::Critic::Policy|Perl::Critic::Policy> modules that are found on
this machine.

=item C<--profile-proto>

Displays an expanded listing of all the
L<Perl::Critic::Policy|Perl::Critic::Policy> modules that are found on
this machine.  For each Policy, the name, default severity and default
themes are shown, as well as the name of any additional parameters
that the Policy supports.  The format is suitable as a prototype for
your F<.perlcriticrc> file.

=item C<--only>

Directs perlcritic to apply only Policies that are explicitly
mentioned in your F<.perlcriticrc> file.  This is useful if you want
to use just a small subset of Policies without having to disable all
the others.  You can set the default value for this option in your
F<.perlcriticrc> file.

=item C<--profile-strictness {warn|fatal|quiet}>

Directs perlcritic how to treat certain recoverable problems found in
a F<.perlcriticrc> or file specified via the C<--profile> option.
Valid values are C<warn> (the default), C<fatal>, and C<quiet>.  For
example, perlcritic normally only warns about profiles referring to
non-existent Policies, but this option can make this situation fatal.
You can set the default value for this option in your F<.perlcriticrc>
file.

=item C<--count>

=item C<-C>

Display only the number of violations for each file.  Use this feature
to get a quick handle on where a large pile of code might need the
most attention.

=item C<--Safari>

Report "Perl Best Practice" citations as section numbers from
L<http://safari.oreilly.com> instead of page numbers from the actual
book.  NOTE: This feature is not implemented yet.

=item C<--color>

This option is on when outputting to a tty.  When set, Severity 5 and 4 are
colored red and yellow, respectively.  Colorization only happens if
L<Term::ANSIColor|Term::ANSIColor> is installed and it only works on
non-Windows environments.  Negate this switch to disable color.  You can set
the default value for this option in your F<.perlcriticrc> file.

Can also be specified as C<--colour>.

=item C<--pager PAGER_COMMAND_STRING>

If set, perlcritic will pipe it's output to the given PAGER_COMMAND_STRING.
You can set the default value for this option in your F<.perlcriticrc> file.

Setting a pager turns off color by default.  You will have to turn color on
explicitly.  If you want color, you'll probably also want to tell your pager
to display raw characters.  For C<less> and C<more>, use the -R switch.

=item C<--doc PATTERN>

Displays the perldoc for all
L<Perl::Critic::Policy|Perl::Critic::Policy> modules that match
C<m/PATTERN/ixms>.  Since Policy modules tend to have rather long
names, this just provides a more convenient way to say something like:
C<"perldoc Perl::Critic::Policy::ValuesAndExpressions::RequireUpperCaseHeredocTerminator">
at the command prompt.

=item C<--quiet>

Suppress the "source OK" message when no violations are found.

=item C<--help>

=item C<-?>

=item C<-H>

Displays a brief summary of options and exits.

=item C<--options>

Displays the descriptions of the options and exits.  While this output
is long, it it nowhere near the length of the output of C<--man>.

=item C<--man>

Displays the complete C<perlcritic> manual and exits.

=item C<--version>

=item C<-V>

Displays the version number of C<perlcritic> and exits.

=back

=head1 CONFIGURATION

Most of the settings for Perl::Critic and each of the Policy modules
can be controlled by a configuration file.  The default configuration
file is called F<.perlcriticrc>.  C<perlcritic> will look for this
file in the current directory first, and then in your home directory.
Alternatively, you can set the C<PERLCRITIC> environment variable to
explicitly point to a different file in another location.  If none of
these files exist, and the C<--profile> option is not given on the
command-line, then all Policies will be loaded with their default
configuration.

The format of the configuration file is a series of INI-style blocks
that contain key-value pairs separated by "=". Comments should start
with "#" and can be placed on a separate line or after the name-value
pairs if you desire.

Default settings for perlcritic itself can be set B<before the first
named block.> For example, putting any or all of these at the top of
your F<.perlcriticrc> file will set the default value for the
corresponding command-line argument.

    severity  = 3                                     #Integer or named level
    only      = 1                                     #Zero or One
    force     = 0                                     #Zero or One
    verbose   = 4                                     #Integer or format spec
    top       = 50                                    #A positive integer
    theme     = (pbp + security) * bugs               #A theme expression
    include   = NamingConventions ClassHierarchies    #Space-delimited list
    exclude   = Variables  Modules::RequirePackage    #Space-delimited list

The remainder of the configuration file is a series of blocks like this:

    [Perl::Critic::Policy::Category::PolicyName]
    severity = 1
    set_themes = foo bar
    add_themes = baz
    arg1 = value1
    arg2 = value2

C<Perl::Critic::Policy::Category::PolicyName> is the full name of a
module that implements the policy.  The Policy modules distributed
with Perl::Critic have been grouped into categories according to the
table of contents in Damian Conway's book B<Perl Best Practices>. For
brevity, you can omit the C<'Perl::Critic::Policy'> part of the module
name.

C<severity> is the level of importance you wish to assign to the
Policy.  All Policy modules are defined with a default severity value
ranging from 1 (least severe) to 5 (most severe).  However, you may
disagree with the default severity and choose to give it a higher or
lower severity, based on your own coding philosophy.  You can set the
C<severity> to an integer from 1 to 5, or use one of the equivalent
names:

    SEVERITY NAME ...is equivalent to... SEVERITY NUMBER
    ----------------------------------------------------
    gentle                                             5
    stern                                              4
    harsh                                              3
    cruel                                              2
    brutal                                             1

C<set_themes> sets the theme for the Policy and overrides its default
theme.  The argument is a string of one or more whitespace-delimited
alphanumeric words.  Themes are case-insensitive.  See L<"POLICY
THEMES"> for more information.

C<add_themes> appends to the default themes for this Policy.  The
argument is a string of one or more whitespace-delimited words.
Themes are case-insensitive.  See L<"POLICY THEMES"> for more
information.

The remaining key-value pairs are configuration parameters that will
be passed into the constructor of that Policy.  The constructors for
most Policy modules do not support arguments, and those that do should
have reasonable defaults.  See the documentation on the appropriate
Policy module for more details.

Instead of redefining the severity for a given Policy, you can
completely disable a Policy by prepending a '-' to the name of the
module in your configuration file.  In this manner, the Policy will
never be loaded, regardless of the C<--severity> given on the command
line.

A simple configuration might look like this:

    #--------------------------------------------------------------
    # I think these are really important, so always load them

    [TestingAndDebugging::RequireUseStrict]
    severity = 5

    [TestingAndDebugging::RequireUseWarnings]
    severity = 5

    #--------------------------------------------------------------
    # I think these are less important, so only load when asked

    [Variables::ProhibitPackageVars]
    severity = 2

    [ControlStructures::ProhibitPostfixControls]
    allow = if unless  # My custom configuration
    severity = cruel   # Same as "severity = 2"

    #--------------------------------------------------------------
    # Give these policies a custom theme.  I can activate just
    # these policies by saying "perlcritic --theme 'larry || curly'"

    [Modules::RequireFilenameMatchesPackage]
    add_themes = larry

    [TestingAndDebugging::RequireTestLabels]
    add_themes = curly moe

    #--------------------------------------------------------------
    # I do not agree with these at all, so never load them

    [-NamingConventions::ProhibitMixedCaseVars]
    [-NamingConventions::ProhibitMixedCaseSubs]

    #--------------------------------------------------------------
    # For all other Policies, I accept the default severity,
    # so no additional configuration is required for them.

Note that all policies included with the Perl::Critic distribution
that have integer parameters accept underscores ("_") in their values,
as with Perl numeric literals.  For example,

    [ValuesAndExpressions::RequireNumberSeparators]
    min_value = 1_000

For additional configuration examples, see the F<perlcriticrc> file
that is included in this F<examples> directory of this distribution.

Damian Conway's own Perl::Critic configuration is also included in
this distribution as F<examples/perlcriticrc-conway>.


=head1 THE POLICIES

A large number of Policy modules are distributed with Perl::Critic.
They are described briefly in the companion document
L<Perl::Critic::PolicySummary|Perl::Critic::PolicySummary> and in more
detail in the individual modules themselves.  Say C<"perlcritic --doc
PATTERN"> to see the perldoc for all Policy modules that match the
regex C<m/PATTERN/ixms>

There are a number of distributions of additional policies on CPAN.
If L<Perl::Critic|Perl::Critic> doesn't contain a policy that you
want, some one may have already written it.  See L<Perl::Critic/"SEE
ALSO"> for a list of some of these distributions.


=head1 POLICY THEMES

Each Policy is defined with one or more "themes".  Themes can be used
to create arbitrary groups of Policies.  They are intended to provide
an alternative mechanism for selecting your preferred set of Policies.
For example, you may wish disable a certain set of Policies when
analyzing test scripts.  Conversely, you may wish to enable only a
specific subset of Policies when analyzing modules.

The Policies that ship with Perl::Critic are have been divided into
the following themes.  This is just our attempt to provide some basic
logical groupings.  You are free to invent new themes that suit your
needs.

    THEME             DESCRIPTION
    ------------------------------------------------------------------------
    core              All policies that ship with Perl::Critic
    pbp               Policies that come directly from "Perl Best Practices"
    bugs              Policies that that prevent or reveal bugs
    maintenance       Policies that affect the long-term health of the code
    cosmetic          Policies that only have a superficial effect
    complexity        Policies that specificaly relate to code complexity
    security          Policies that relate to security issues
    tests             Policies that are specific to test scripts

Say C<"perlcritic --list"> to get a listing of all available policies
and the themes that are associated with each one.  You can also change
the theme for any Policy in your F<.perlcriticrc> file.  See the
L<"CONFIGURATION"> section for more information about that.

Using the C<--theme> command-line option, you can create an
arbitrarily complex rule that determines which Policies to apply.
Precedence is the same as regular Perl code, and you can use
parentheses to enforce precedence as well.  Supported operators are:

    Operator    Altertative    Example
    -----------------------------------------------------------------
    &&          and            'pbp && core'
    ||          or             'pbp || (bugs && security)'
    !           not            'pbp && ! (portability || complexity)'

Theme names are case-insensitive.  If the C<--theme> is set to an
empty string, then it evaluates as true all Policies.


=head1 BENDING THE RULES

Perl::Critic takes a hard-line approach to your code: either you
comply or you don't.  In the real world, it is not always practical
(or even possible) to fully comply with coding standards.  In such
cases, it is wise to show that you are knowingly violating the
standards and that you have a Damn Good Reason (DGR) for doing so.

To help with those situations, you can direct Perl::Critic to ignore
certain lines or blocks of code by using pseudo-pragmas:

  require 'LegacyLibaray1.pl';  ## no critic
  require 'LegacyLibrary2.pl';  ## no critic

  for my $element (@list) {

      ## no critic

      $foo = "";               #Violates 'ProhibitEmptyQuotes'
      $barf = bar() if $foo;   #Violates 'ProhibitPostfixControls'
      #Some more evil code...

      ## use critic

      #Some good code...
      do_something($_);
  }

The C<"## no critic"> comments direct Perl::Critic to ignore the
remaining lines of code until the end of the current block, or until a
C<"## use critic"> comment is found (whichever comes first).  If the
C<"## no critic"> comment is on the same line as a code statement,
then only that line of code is overlooked.  To direct perlcritic to
ignore the C<"## no critic"> comments, use the C<--force> option.

A bare C<"## no critic"> comment disables all the active Policies.  If
you wish to disable only specific Policies, add a list of Policy names
as arguments just as you would for the C<"no strict"> or C<"no
warnings"> pragma.  For example, this would disable the
C<ProhibitEmptyQuotes> and C<ProhibitPostfixControls> policies until
the end of the block or until the next C<"## use critic"> comment
(whichever comes first):

    ## no critic (EmptyQuotes, PostfixControls);

    # Now exempt from ValuesAndExpressions::ProhibitEmptyQuotes
    $foo = "";

    # Now exempt ControlStructures::ProhibitPostfixControls
    $barf = bar() if $foo;

    # Still subject to ValuesAndExpression::RequireNumberSeparators
    $long_int = 10000000000;

Since the Policy names are matched against the C<"## no critic">
arguments as regular expressions, you can abbreviate the Policy names
or disable an entire family of Policies in one shot like this:

    ## no critic (NamingConventions)

    # Now exempt from NamingConventions::ProhibitMixedCaseVars
    my $camelHumpVar = 'foo';

    # Now exempt from NamingConventions::ProhibitMixedCaseSubs
    sub camelHumpSub {}

The argument list must be enclosed in parentheses and must contain one
or more comma-separated barewords (i.e. don't use quotes).  The C<"##
no critic"> pragmas can be nested, and Policies named by an inner
pragma will be disabled along with those already disabled an outer
pragma.

Some Policies like C<Subroutines::ProhibitExcessComplexity> apply to
an entire block of code.  In those cases, C<"## no critic"> must
appear on the line where the violation is reported.  For example:

    sub complicated_function {  ## no critic (ProhibitExcessComplexity)
        # Your code here...
    }

Some Policies like C<Documentation::RequirePodSections> apply to the
entire document, in which case violations are reported at line 1.  But
if the file requires a shebang line, it is impossible to put C<"## no
critic"> on the first line of the file.  This is a known limitation
and it will be addressed in a future release.  As a workaround, you
can disable the affected policies at the command-line or in your
F<.perlcriticrc> file.  But beware that this will affect the analysis
of B<all> files.

Use this feature wisely.  C<"## no critic"> should be used in the
smallest possible scope, or only on individual lines of code. And you
should always be as specific as possible about which policies you want
to disable (i.e. never use a bare C<"## no critic">).  If Perl::Critic
complains about your code, try and find a compliant solution before
resorting to this feature.


=head1 EDITOR INTEGRATION

For ease-of-use, C<perlcritic> can be integrated with your favorite
text editor.  The output-formatting capabilities of C<perlcritic> are
specifically intended for use with the "grep" or "compile" modes
available in editors like C<emacs> and C<vim>.  In these modes, you
can run an arbitrary command and the editor will parse the output into
an interactive buffer that you can click on and jump to the relevant
line of code.

The Perl::Critic team thanks everyone who has helped integrate Perl-Critic
with their favorite editor.  Your contributions in particular have made
Perl-Critic a convenient and user-friendly tool for Perl developers of all
stripes.  We sincerely appreciate your hard work.


=head2 EMACS

Joshua ben Jore has authored a minor-mode for emacs that allows you to
run perlcritic on the current region or buffer.  You can run it on
demand, or configure it to run automatically when you save the buffer.
The output appears in a hot-linked compiler buffer.  The code and
installation instructions can be found in the F<extras> directory
inside this distribution.


=head2 VIM

Scott Peshak has published F<perlchecker.vim>, which is available at
L<http://www.vim.org/scripts/script.php?script_id=1731>.


=head2 gVIM

Fritz Mehner recently added support for C<perlcritic> to his fantastic
gVIM plugin.  In addition to providing a very Perlish IDE, Fritz's
plugin enables one-click access to C<perlcritic> and many other very
useful utilities.  And all is seamlessly integrated into the editor.
See L<http://lug.fh-swf.de/vim/vim-perl/screenshots-en.html> for
complete details.


=head2 EPIC

EPIC is an open source Perl IDE based on the Eclipse platform.
Features include syntax highlighting, on-the-fly syntax check,
content assist, code completion, perldoc support, source formatting 
with L<Perl::Tidy>, code templates, a regular expression editing tool, 
and integration with the Perl debugger.  Recent versions of EPIC also 
have built-in support for Perl::Critic.  At least one Perl::Critic
contributor swears by EPIC.  Go to L<http://e-p-i-c.sourceforge.net> 
for more information about EPIC.

=head2 BBEdit

Josh Clark has produced an excellent Perl-Critic plugin for BBEdit. A
copy is included in this distribution at
F<extras/perl_critic_for_bbedit-1_0.zip>. See
L<http://beta.bigmedium.com/projects/bbedit-perl-critic/index.shtml>
for screenshots and additional installation info.  Apple users
rejoice!


=head2 Komodo

Komodo is a proprietary IDE for Perl and several other dynamic
languages.  Free trial copies of Komodo can be obtained from the
ActiveState website at L<http://www.activestate.com>. For instructions
on integrating F<perlcritic> with Komodo, see
F<extras/KomodoIntegration.pod> in this distribution.


=head1 EXIT STATUS

If C<perlcritic> has any errors itself, exits with status == 1.  If
there are no errors, but C<perlcritic> finds Policy violations in your
source code, exits with status == 2.  If there were no errors and no
violations were found, exits with status == 0.


=head1 THE L<Perl::Critic|Perl::Critic> PHILOSOPHY

=over

Coding standards are deeply personal and highly subjective.  The goal
of Perl::Critic is to help you write code that conforms with a set of
best practices.  Our primary goal is not to dictate what those
practices are, but rather, to implement the practices discovered by
others.  Ultimately, you make the rules -- Perl::Critic is merely a
tool for encouraging consistency.  If there is a policy that you think
is important or that we have overlooked, we would be very grateful for
contributions, or you can simply load your own private set of policies
into Perl::Critic.

=back


=head1 EXTENDING THE CRITIC

The modular design of Perl::Critic is intended to facilitate the
addition of new Policies.  You'll need to have some understanding of
L<PPI|PPI>, but most Policy modules are pretty straightforward and
only require about 20 lines of code, and half of those lines are
simple use statements and simple declarations..  Please see the
L<Perl::Critic::DEVELOPER|Perl::Critic::DEVELOPER> file included in
this distribution for a step-by-step demonstration of how to create
new Policy modules.

If you develop any new Policy modules, feel free to send them to C<<
<thaljef@cpan.org> >> and I'll be happy to put them into the
Perl::Critic distribution.  Or if you would like to work on the
Perl::Critic project directly, check out our repository at
L<http://perlcritic.tigris.org>.  To subscribe to our mailing list,
send a message to C<< <dev-subscribe@perlcritic.tigris.org> >>.

The Perl::Critic team is also available for hire.  If your
organization has its own coding standards, we can create custom
Policies to enforce your local guidelines.  Or if your code base is
prone to a particular defect pattern, we can design Policies that will
help you catch those costly defects B<before> they go into production.
To discuss your needs with the Perl::Critic team, just contact C<<
<thaljef@cpan.org> >>.


=head1 CONTACTING THE DEVELOPMENT TEAM

You are encouraged to subscribe to the mailing list; send a message to
C<< <users-subscribe@perlcritic.tigris.org> >>.  See also
L<the archives|http://perlcritic.tigris.org/servlets/SummarizeList?listName=users>.
You can also contact the author at C<< <thaljef@cpan.org> >>.

At least one member of the development team has started hanging around
in L<irc://irc.perl.org/#perlcritic>.


=head1 SEE ALSO

There are a number of distributions of additional Policies available.
A few are listed here:

L<Perl::Critic::More|Perl::Critic::More>
L<Perl::Critic::Bangs|Perl::Critic::Bangs>
L<Perl::Critic::Lax|Perl::Critic::Lax>
L<Perl::Critic::StricterSubs|Perl::Critic::StricterSubs>
L<Perl::Critic::Swift|Perl::Critic::Swift>

These distributions enable you to use Perl::Critic in your unit tests:

L<Test::Perl::Critic|Test::Perl::Critic>
L<Test::Perl::Critic::Progressive|Test::Perl::Critic::Progressive>

There are also a couple of distributions that will install all the
Perl::Critic related modules known to the development team:

L<Bundle::Perl::Critic|Bundle::Perl::Critic>
L<Task::Perl::Critic|Task::Perl::Critic>


=head1 BUGS

Scrutinizing Perl code is hard for humans, let alone machines.  If you
find any bugs, particularly false-positives or false-negatives from a
Perl::Critic::Policy, please submit them to
L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Perl-Critic>.  Thanks.

Most policies will produce false-negatives if they cannot understand a
particular block of code.


=head1 CREDITS

Adam Kennedy - For creating L<PPI|PPI>, the heart and soul of
L<Perl::Critic|Perl::Critic>.

Damian Conway - For writing B<Perl Best Practices>, finally :)

Chris Dolan - For contributing the best features and Policy modules.

Andy Lester - Wise sage and master of all-things-testing.

Elliot Shank - The self-proclaimed quality freak.

Giuseppe Maxia - For all the great ideas and positive encouragement.

and Sharon, my wife - For putting up with my all-night code sessions.


=head1 AUTHOR

Jeffrey Ryan Thalhammer <thaljef@cpan.org>


=head1 COPYRIGHT

Copyright (c) 2005-2008 Jeffrey Ryan Thalhammer.  All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.  The full text of this license
can be found in the LICENSE file included with this module.

=cut

##############################################################################
# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 78
#   indent-tabs-mode: nil
#   c-indentation-style: bsd
# End:
# ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab shiftround :
