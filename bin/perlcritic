#!/usr/bin/perl

##############################################################################
#      $URL$
#     $Date$
#   $Author$
# $Revision$
#        ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab :
##############################################################################

package main;

use strict;
use warnings;
use Carp qw(confess);
use English qw(-no_match_vars);
use Getopt::Long qw(GetOptions);
use List::Util qw(first);
use Perl::Critic::Utils qw( :characters :severities &policy_short_name );
use Perl::Critic::Violation qw();
use Pod::Usage qw(pod2usage);

#-----------------------------------------------------------------------------

our $VERSION = 1.053;

#-----------------------------------------------------------------------------
# Begin script.  Don't run when loaded as a library

my @FILES = ();
my $CRITIC = undef;
exit run() if not caller;

#-----------------------------------------------------------------------------
# Begin subroutines

sub run {
    my %options    = get_options();
    @FILES         = get_input(@ARGV);
    my $violations = critique(\%options, @FILES);
    my $status     = defined $violations ? ( $violations ? 2 : 0 ) : 1;
    return $status;
}

#-----------------------------------------------------------------------------

sub get_options {

    my %opts = _parse_command_line();
    _dispatch_special_requests( %opts );
    _validate_options( %opts );

    # Convert severity shortcut options.  If multiple shortcuts
    # are given, the lowest one wins.  If an explicit -severity
    # option has been given, then the shortcuts are ignored. The
    # @SEVERITY_NAMES variable is exported by Perl::Critic::Utils.
    $opts{severity} ||=  first { exists $opts{$_} } @SEVERITY_NAMES;
    $opts{severity} ||=  first { exists $opts{$_} } (1 .. 5);


    # If -top is specified, default the severity level to 1, unless an
    # explicit severity is defined.  This provides us flexibility to
    # report top-offenders across just some or all of the severity levels.
    # We also default the -top count to twenty if none is given
    if ( exists $opts{top} ) {
        $opts{severity} ||= 1;
        $opts{top} ||= 20;
    }

    #Override profile, if -noprofile is specified
    if ( exists $opts{noprofile} ) {
        $opts{profile} = q{};
    }

    # I've adopted the convention of using key-value pairs for
    # arguments to most functions.  And to increase legibility,
    # I have also adopted the familiar command-line practice
    # of denoting argument names with a leading dash (-).
    my %dashed_opts = map { ( "-$_" => $opts{$_} ) } keys %opts;
    return %dashed_opts;
}

#-----------------------------------------------------------------------------

sub _parse_command_line {
    my %opts      = ();
    my @opt_specs = _get_option_specification();
    Getopt::Long::Configure('no_ignore_case');
    GetOptions( \%opts, @opt_specs ) || pod2usage();           #Exits
    return %opts;
}

#-----------------------------------------------------------------------------

sub _dispatch_special_requests {
    my (%opts) = @_;
    if ( $opts{help}         ) { pod2usage( -verbose => 0 )   }  #Exits
    if ( $opts{man}          ) { pod2usage( -verbose => 2 )   }  #Exits
    if ( $opts{Version}      ) { print "$VERSION\n"; exit 0;  }  #Exits
    if ( $opts{list}         ) { render_policy_listing();     }  #Exits
    if ( $opts{profileproto} ) { render_profile_prototype();  }  #Exits
    if ( $opts{doc}          ) { policy_docs( $opts{doc} );   }  #Exits
    return 1;
}

#-----------------------------------------------------------------------------

sub _validate_options {
    my (%opts) = @_;
    my $msg = q{};


    if ( $opts{noprofile} && $opts{profile} ) {
        $msg .= qq{Warning: Cannot use -noprofile with -profile option.\n};
    }

    if ( $opts{verbose} && $opts{verbose} !~ m{(?: \d+ | %[mfFlcedrps] )}mx){
        $msg .= qq{Warning: -verbose arg "$opts{verbose}" looks odd.  };
        $msg .= qq{Perhaps you meant to say "-verbose 3 $opts{verbose}"\n};
    }

    if ( exists $opts{top} && $opts{top} < 0 ) {
        $msg .= qq{Warning: -top argument "$opts{top}" is negative.  };
        $msg .= qq{Perhaps you meant to say "$opts{top} -top".\n};
    }

    if (exists $opts{severity} && ($opts{severity}<1 || $opts{severity}>5)){
        $msg .= qq{Warning: -severity arg "$opts{severity}" out of range.  };
        $msg .= qq{Severities range from ""'(lowest) to "5" (highest).\n};
    }


    if ( $msg ) {
        pod2usage( -exitstatus => 1, -message => $msg, -verbose => 0); #Exits
    }


    return 1;
}

#-----------------------------------------------------------------------------

sub get_input {

    if ( !@_ || (@_ == 1 && $_[0] eq q{-}) )  {

        # Reading code from STDIN.  All the code is slurped into
        # a string.  PPI will barf if the string is just whitespace.
        my $code_string = do { local $RS = undef; <STDIN> };

        # Notice if STDIN was closed (pipe error, etc)
        if ( ! defined $code_string ) {
            $code_string = q{};
        }

        $code_string =~ m{ \S+ }mx || confess qq{Nothing to critique.\n};
        return \$code_string;    #Convert to SCALAR ref for PPI
    }
    else {

        # Test to make sure all the specified files or directories
        # actually exist.  If any one of them is bogus, then die.
        if ( my $nonexistant = first { ! -e $_ } @_ ) {
            my $msg = qq{No such file or directory: '$nonexistant'};
            pod2usage( -exitstatus => 1, -message => $msg, -verbose => 0);
        }

        # Reading code from files or dirs.  If argument is a file,
        # then we process it as-is (even though it may not actually
        # be Perl code).  If argument is a directory, recursively
        # search the directory for files that look like Perl code.
        return map { -d $_ ? Perl::Critic::Utils::all_perl_files($_) : $_ } @_;
    }
}

#------------------------------------------------------------------------------

sub critique {

    my ( $opts_ref, @files ) = @_;
    @files || die "No perl files were found.\n";

    # Perl::Critic has lots of dependencies, so loading is delayed
    # until it is really needed.  This hack reduces startup time for
    # doing other things like getting the version number or dumping
    # the man page. Arguably, those things are pretty rare, but hey,
    # why not save a few seconds if you can.

    require Perl::Critic;
    $CRITIC = Perl::Critic->new( %{$opts_ref} );
    my $number_of_violations = undef;

    for my $file (@files) {

        eval {

            my @violations = $CRITIC->critique($file);
            render_report( $file, $opts_ref, @violations );
            $number_of_violations += scalar @violations;
        };

        confess qq{Fatal error while critiquing "$file": $EVAL_ERROR}
            if $EVAL_ERROR;
    }

    if ( $opts_ref->{-statistics} ) {
        my $stats = $CRITIC->statistics();
        report_statistics( $opts_ref, $stats );
    }

    return $number_of_violations;
}

#------------------------------------------------------------------------------

sub render_report {

    my ( $file, $opts_ref, @violations ) = @_;
    my $count = scalar @violations;


    # Only report the number of violations, if asked.
    if( $opts_ref->{-count} ){
        ref $file || print "$file: ";
        print "$count\n";
        return $count;
    }

    # Hail all-clear unless we should shut up.
    if( !@violations && !$opts_ref->{-quiet} ) {
        ref $file || print "$file ";
        print "source OK\n";
        return 0;
    }

    # Otherwise, format and print violations
    my $verbosity = $CRITIC->config->verbose();
    # $verbosity can be numeric or string, so use "eq" for comparison;
    $verbosity = ($verbosity eq '4' && @FILES > 1) ? 5 : $verbosity;
    my $fmt = Perl::Critic::Utils::verbosity_to_format( $verbosity );
    if (not -f $file) { $fmt =~ s{\%[fF]}{STDIN}mx; } #HACK!
    Perl::Critic::Violation::set_format( $fmt );

    print $opts_ref->{-nocolor} ? @violations
                                : _colorize_by_severity(@violations);
    return $count;
}

#-----------------------------------------------------------------------------

sub report_statistics {
    my ($opts_ref, $statistics) = @_;

    if (
            $statistics->total_violations()
        or  not $opts_ref->{-quiet} and $statistics->modules()
    ) {
        print "\n"; # There's prior output that we want to separate from.
    }

    my $subs = $statistics->subs();
    my $statements = $statistics->statements() - $subs;

    print _commaify($statistics->modules()), " files.\n";
    print _commaify($subs), " subroutines/methods.\n";
    print _commaify($statements), " statements.\n";
    print _commaify($statistics->lines_of_code()), " lines of code.\n";

    my $average_sub_mccabe = $statistics->average_sub_mccabe();
    if (defined $average_sub_mccabe) {
        printf
            "\nAverage McCabe score of subroutines was %.2f.\n",
            $average_sub_mccabe;
    }

    print "\n";

    print _commaify($statistics->total_violations()), " violations.\n";

    my $violations_per_line = $statistics->violations_per_line_of_code();
    if (defined $violations_per_line) {
        printf
            "Violations per line of code was %.3f.\n",
            $violations_per_line;
    }

    if ( $statistics->total_violations() ) {
        print "\n";

        my %severity_violations = %{ $statistics->violations_by_severity() };
        foreach my $severity ( reverse sort keys %severity_violations ) {
            print
                _commaify($severity_violations{$severity}),
                " severity $severity violations.\n";
        }

        print "\n";

        my %policy_violations = %{ $statistics->violations_by_policy() };
        foreach my $policy ( sort keys %policy_violations ) {
            print
                _commaify($policy_violations{$policy}),
                ' violations of ',
                policy_short_name($policy),
                ".\n";
        }
    }

    return;
}

#-----------------------------------------------------------------------------

# Only works for integers.
sub _commaify {
    my ( $number ) = @_;

    while ($number =~ s/ \A ( [-+]? \d+ ) ( \d{3} ) /$1,$2/xms) {
        # nothing
    }

    return $number;
}

#-----------------------------------------------------------------------------

sub _get_option_specification {

    return qw(
        5 4 3 2 1
        Safari
        Version
        brutal
        count|C
        cruel
        doc=s
        exclude=s@
        force!
        gentle
        harsh
        help|?|H
        include=s@
        list
        man
        nocolor
        noprofile
        only!
        profile=s
        profileproto
        quiet
        severity=i
        singlepolicy=s
        stern
        statistics!
        strictprofile!
        theme=s
        top:i
        verbose=s
    );
}

#-----------------------------------------------------------------------------

sub _colorize_by_severity {
    my (@violations) = @_;
    return @violations if not _at_tty();
    return @violations if _this_is_windows();
    return @violations if not eval { require Term::ANSIColor };

    my %color_of = ( 5 => 'bold red', 4 => 'yellow');
    return map { _colorize( "$_", $color_of{$_->severity()} ) } @violations;

}

#-----------------------------------------------------------------------------

sub _colorize {
    my ($string, $color) = @_;
    return $string if not defined $color;
    return  Term::ANSIColor::colored( $string, $color );
}

#-----------------------------------------------------------------------------

sub _this_is_windows {
    return 1 if $OSNAME =~ m/MSWin32/mx;
    return 0;
}

#-----------------------------------------------------------------------------

sub _at_tty {
    return -t STDOUT; ##no critic 'InteractiveTest';
}

#-----------------------------------------------------------------------------

sub render_policy_listing {

    my $type = shift;
    require Perl::Critic::PolicyListing;
    require Perl::Critic;

    my %pc_params = (-profile => $EMPTY, -severity => 1);
    my @pols = Perl::Critic->new( %pc_params )->policies();
    my $listing = Perl::Critic::PolicyListing->new( -policies => \@pols );
    print $listing;
    exit 0;
}

#-----------------------------------------------------------------------------

sub render_profile_prototype {

    require Perl::Critic::ProfilePrototype;
    require Perl::Critic;

    my %pc_params = (-profile => $EMPTY, -severity => 1);
    my @pols = Perl::Critic->new( %pc_params )->policies();
    my $prototype = Perl::Critic::ProfilePrototype->new( -policies => \@pols );
    print $prototype;
    exit 0;
}

#-----------------------------------------------------------------------------

sub policy_docs {

    my $pattern = shift;
    require Perl::Critic;

    my %pc_params = (-profile => $EMPTY, -severity => 1);
    my @policies  = Perl::Critic::Config->new( %pc_params )->policies();
    my @matches   = grep { $_ =~ m/$pattern/imx } @policies;

    for my $matching_policy ( @matches ) {
        my @perldoc_cmd = qw(perldoc -T); #-T means don't send to pager
        system @perldoc_cmd, ref $matching_policy;
    }
    exit 0;
}

1;

__END__

#-----------------------------------------------------------------------------

=pod

=for stopwords DGR INI-style vim-fu minibuffer -noprofile API ben Jore
formatter Peshak pbp Komodo screenshots

=head1 NAME

C<perlcritic> - Command-line interface to critique Perl source

=head1 SYNOPSIS

  perlcritic [-12345 | -brutal | -cruel | -harsh | -stern | -gentle]
             [-severity number | name] [-profile file | -noprofile]
             [-top [ number ]] [-theme expression] [-include pattern]
             [-exclude pattern] [-singlepolicy pattern] [-only | -noonly]
             [-strictprofile | -nostrictprofile] [-force | -noforce]
             [-statistics] [-verbose number | format] [-nocolor]
             [-quiet] {FILE | DIRECTORY | STDIN}

  perlcritic -doc pattern [...]

  perlcritic {-list | -profileproto | -help | -man | -Version}

=head1 DESCRIPTION

C<perlcritic> is a Perl source code analyzer.  It is the executable
front-end to the L<Perl::Critic> engine, which attempts to identify
awkward, hard to read, error-prone, or unconventional constructs in
your code.  Most of the rules are based on Damian Conway's book B<Perl
Best Practices>.  However, C<perlcritic> is B<not> limited to
enforcing PBP, and it will even support rules that contradict Conway.
All rules can easily be configured or disabled to your liking.

If you want to integrate C<perlcritic> with your build process, the
L<Test::Perl::Critic> module provides a nice interface that is
suitable for test scripts.  For ultimate convenience (at the expense
of some flexibility) see the L<criticism> pragma.

Win32 and ActivePerl users can find PPM distributions of Perl::Critic
at L<http://theoryx5.uwinnipeg.ca/ppms/>.

If you'd like to try L<Perl::Critic> without installing anything,
there is a web-service available at L<http://perlcritic.com>.  The
web-service does not yet support all the configuration features that
are available in the native Perl::Critic API, but it should give you a
good idea of what it does.  You can also invoke the perlcritic
web-service from the command-line by doing an HTTP-post, such as one
of these:

   $> POST http://perlcritic.com/perl/critic.pl < MyModule.pm
   $> lwp-request -m POST http://perlcritic.com/perl/critic.pl < MyModule.pm
   $> wget -q -O - --post-file=MyModule.pm http://perlcritic.com/perl/critic.pl

Please note that the perlcritic web-service is still alpha code.  The
URL and interface to the service are subject to change.

=head1 USAGE EXAMPLES

Before getting into all the gory details, here are some basic usage
examples to help get you started.

  #Report only most severe violations (severity = 5)
  perlcritic YourModule.pm

  #Same as above, but read input from STDIN
  perlcritic

  #Recursively process all Perl files beneath directory
  perlcritic /some/directory

  #Report slightly less severe violations too (severity >= 4)
  perlcritic -4 YourModule.pm

  #Same as above, but using named severity level
  perlcritic -stern YourModule.pm

  #Report all violations, regardless of severity (severity >= 1)
  perlcritic -1 YourModule.pm

  #Same as above, but using named severity level
  perlcritic -brutal YourModule.pm

  #Report only violations of things from "Perl Best Practices"
  perlcritic -theme pbp YourModule.pm

  #Report top 20 most severe violations (severity >= 1)
  perlcritic -top YourModule.pm

  #Report additional violations of Policies that match m/variables/ix
  perlcritic -include variables YourModule.pm

=head1 ARGUMENTS

The arguments are paths to the files you wish to analyze.  You may
specify multiple files.  If an argument is a directory, C<perlcritic>
will analyze all Perl files below the directory.  If no arguments
are specified, then input is read from STDIN.

=head1 OPTIONS

Option names can be abbreviated to uniqueness and can be stated with
singe or double dashes, and option values can be separated from the
option name by a space or '=' (as with L<Getopt::Long>).  Option names
are also case-sensitive.

=over 8

=item C<-profile FILE>

Directs C<perlcritic> to use a profile named by FILE rather than looking
for the default F<.perlcriticrc> file in the current directory or your
home directory.  See L<"CONFIGURATION"> for more information.

=item C<-noprofile>

Directs C<perlcritic> not to load any configuration file, thus reverting
to the default configuration for all Policies.

=item C<-severity N>

Directs C<perlcritic> to only apply Policies with a severity greater than
C<N>.  Severity values are integers ranging from 1 (least severe) to 5 (most
severe).  The default is 5.  For a given C<-profile>, decreasing the
C<-severity> will usually produce more violations.  You can set the default
value for this option in your F<.perlcriticrc> file.  You can also redefine
the C<severity> for any Policy in your F<.perlcriticrc> file.  See
L<"CONFIGURATION"> for more information.

=item C<-5 | -4 | -3 | -2 | -1>

These are numeric shortcuts for setting the C<-severity> option.  For example,
C<"-4"> is equivalent to C<"-severity 4">.  If multiple shortcuts are
specified, then the most restrictive one wins.  If an explicit C<-severity>
option is also given, then all shortcut options are silently ignored.  NOTE:
Be careful not to put one of the number severity shortcut options immediately
after the C<-top> flag or C<perlcritic> will interpret it as the number of
violations to report.

=item C<-severity NAME>

If it is difficult for you to remember whether severity "5" is the most
or least restrictive level, then you can use one of these named values:

    SEVERITY NAME   ...is equivalent to...   SEVERITY NUMBER
    --------------------------------------------------------
    -severity gentle                             -severity 5
    -severity stern                              -severity 4
    -severity harsh                              -severity 3
    -severity cruel                              -severity 2
    -severity brutal                             -severity 1

=item C<-gentle | -stern | -harsh | -cruel | -brutal>

These are named shortcuts for setting the C<-severity> option.  For example,
C<"-cruel"> is equivalent to C<"-severity 2">.  If multiple shortcuts are
specified, then the most restrictive one wins.  If an explicit C<-severity>
option is also given, then all shortcut options are silently ignored.

=item C<-theme RULE>

Directs C<perlcritic> to apply only Policies with themes that satisfy the
C<RULE>.  Themes are arbitrary names for groups of related policies.  You can
combine theme names with boolean operators to create an arbitrarily complex
C<RULE>.  For example, the following would apply only Policies that have a
'bugs' AND 'pbp' theme:

  $> perlcritic -theme='bugs && pbp' MyModule.pm

Unless the C<-severity> option is explicitly given, setting C<-theme> silently
causes the C<-severity> to be set to 1.  You can set the default value for
this option in your F<.perlcriticrc> file.  See the L<"POLICY THEMES"> section
for more information about themes.

=item C<-include PATTERN>

Directs C<perlcritic> to apply additional Policies that match the regex
C</PATTERN/imx>.  Use this option to temporarily override your profile and/or
the severity settings at the command-line.  For example:

  perlcritic -include=layout my_file.pl

This would cause C<perlcritic> to apply all the C<CodeLayout::*> policies even
if they have a severity level that is less than the default level of 5, or
have been disabled in your F<.perlcriticrc> file.  You can specify multiple
C<-include> options and you can use it in conjunction with the C<-exclude>
option.  Note that C<-exclude> takes precedence over C<-include> when a Policy
matches both patterns.  You can set the default value for this option in your
F<.perlcriticrc> file.

=item C<-exclude PATTERN>

Directs C<perlcritic> to not apply any Policy that matches the regex
C</PATTERN/imx>.  Use this option to temporarily override your profile and/or
the severity settings at the command-line.  For example:

  perlcritic -exclude=strict my_file.pl

This would cause C<perlcritic> to not apply the C<RequireUseStrict> and
C<ProhibitNoStrict> Policies even though they have the highest severity level.
You can specify multiple C<-exclude> options and you can use it in conjunction
with the C<-include> option.  Note that C<-exclude> takes precedence over
C<-include> when a Policy matches both patterns.  You can set the default
value for this option in your F<.perlcriticrc> file.

=item C<-singlepolicy PATTERN>

Directs C<perlcritic> to apply just one Policy module matching the regex
C</PATTERN/imx>, and exclude all other Policies.  This option has precedence
over the C<-severity>, C<-theme>, C<-include>, C<-exclude>, and C<-only>
options.  For example:

  perlcritic -singlepolicy=nowarnings my_file.pl

This would cause C<perlcritic> to apply just the C<ProhibitNoWarnings> Policy,
regardless of the severity level setting.  No other Policies would be applied.

This is equivalent to what one might intend by...

  perlcritic -exclude=. -include=nowarnings my_file.pl

...but this won't work because the C<-exclude> option overrides the
C<-include> option.

The equivalent of this option can be accomplished by creating a custom profile
containing only the desired policy and then running...

  perlcritic -profile=customprofile -only my_file.pl

=item C<-top [ N ]>

Directs C<perlcritic> to report only the top C<N> Policy violations in each
file, ranked by their severity.  If C<N> is not specified, it defaults to 20.
If the C<-severity> option (or one of the shortcuts) is not explicitly given,
the C<-top> option implies that the minimum severity level is "1"
(i.e. "brutal"). Users can redefine the severity for any Policy in their
F<.perlcriticrc> file.  See L<"CONFIGURATION"> for more information.  You can
set the default value for this option in your F<.perlcriticrc> file.  NOTE: Be
careful not to put one of the severity shortcut options immediately after the
C<-top> flag or C<perlcritic> will interpret it as the number of violations to
report.

=item C<-force>

Directs C<perlcritic> to ignore the magical C<"## no critic"> pseudo-pragmas
in the source code. See L<"BENDING THE RULES"> for more information.  You can
set the default value for this option in your F<.perlcriticrc> file.

=item C<-statistics>

Causes several statistics about the code being scanned and the violations
found to be reported after any other output.

=item C<-verbose N | FORMAT>

Sets the verbosity level or format for reporting violations.  If given a
number (C<N>), C<perlcritic> reports violations using one of the predefined
formats described below.  If given a string (C<FORMAT>), it is interpreted to
be an actual format specification.  If the C<-verbose> option is not
specified, it defaults to either 4 or 5, depending on whether multiple files
were given as arguments to C<perlcritic>.  You can set the default value for
this option in your F<.perlcriticrc> file.

    Verbosity     Format Specification
    -----------   -------------------------------------------------------------
     1            "%f:%l:%c:%m\n",
     2            "%f: (%l:%c) %m\n",
     3            "%m at %f line %l\n",
     4            "%m at line %l, column %c.  %e.  (Severity: %s)\n",
     5            "%f: %m at line %l, column %c.  %e.  (Severity: %s)\n",
     6            "%m at line %l, near '%r'.  (Severity: %s)\n",
     7            "%f: %m at line %l near '%r'.  (Severity: %s)\n",
     8            "[%p] %m at line %l, column %c.  (Severity: %s)\n",
     9            "[%p] %m at line %l, near '%r'.  (Severity: %s)\n",
    10            "%m at line %l, column %c.\n  %p (Severity: %s)\n%d\n",
    11            "%m at line %l, near '%r'.\n  %p (Severity: %s)\n%d\n"

Formats are a combination of literal and escape characters similar to the way
C<sprintf> works.  See L<String::Format> for a full explanation of the
formatting capabilities.  Valid escape characters are:

    Escape    Meaning
    -------   ----------------------------------------------------------------
    %c        Column number where the violation occurred
    %d        Full diagnostic discussion of the violation
    %e        Explanation of violation or page numbers in PBP
    %F        Just the name of the file where the violation occurred.
    %f        Path to the file where the violation occurred.
    %l        Line number where the violation occurred
    %m        Brief description of the violation
    %P        Full name of the Policy module that created the violation
    %p        Name of the Policy without the Perl::Critic::Policy:: prefix
    %r        The string of source code that caused the violation
    %s        The severity level of the violation

The purpose of these formats is to provide some compatibility with text
editors that have an interface for parsing certain kinds of input. See
L<"EDITOR INTEGRATION"> for more information about that.

=item C<-list>

Displays a condensed listing of all the L<Perl::Critic::Policy> modules that
are found on this machine.  For each Policy, the name, default severity and
default themes are shown.

=item C<-profileproto>

Displays an expanded listing of all the L<Perl::Critic::Policy> modules that
are found on this machine.  For each Policy, the name, default severity and
default themes are shown, as well as the name of any additional parameters
that the Policy supports.  The format is suitable as a prototype for your
F<.perlcriticrc> file.

=item C<-only>

Directs perlcritic to apply only Policies that are explicitly mentioned in
your F<.perlcriticrc> file.  This is useful if you want to use just a small
subset of Policies without having to disable all the others.  You can set the
default value for this option in your F<.perlcriticrc> file.

=item C<-strictprofile>

Directs perlcritic to make certain warnings about problems found in a
F<.perlcriticrc> or file specified via the C<-profile> option fatal.  In
particular, perlcritic normally only warns about profiles referring to
non-existent Policies, but this option makes this situation fatal.  You can
set the default value for this option in your F<.perlcriticrc> file.

=item C<-count>

=item C<-C>

Display only the number of violations for each file.  Use this feature to get
a quick handle on where a large pile of code might need the most attention.

=item C<-Safari>

Report "Perl Best Practice" citations as section numbers from
L<http://safari.oreilly.com> instead of page numbers from the actual book.
NOTE: This feature is not implemented yet.

=item C<-nocolor>

By default, Severity 5 and 4 are colored red and yellow, respectively.
Colorization only happens if STDOUT is a tty and L<Term::ANSIColor> is
installed.  And it only works on non-windows environments.  Set this switch to
disable color.

=item C<-doc PATTERN>

Displays the perldoc for all L<Perl::Critic::Policy> modules that match
C<m/PATTERN/imx>.  Since Policy modules tend to have rather long names, this
just provides a more convenient way to say something like: C<"perldoc
Perl::Critic::Policy::ValuesAndExpressions::RequireUpperCaseHeredocTerminator">
at the command prompt.

=item C<-quiet>

Suppress the "source OK" message when no violations are found.

=item C<-help>

=item C<-?>

=item C<-H>

Displays a brief summary of options and exits.

=item C<-man>

Displays the complete C<perlcritic> manual and exits.

=item C<-Version>

=item C<-V>

Displays the version number of C<perlcritic> and exits.

=back

=head1 CONFIGURATION

Most of the settings for Perl::Critic and each of the Policy modules can be
controlled by a configuration file.  The default configuration file is called
F<.perlcriticrc>.  C<perlcritic> will look for this file in the current
directory first, and then in your home directory.  Alternatively, you can set
the C<PERLCRITIC> environment variable to explicitly point to a different file
in another location.  If none of these files exist, and the C<-profile> option
is not given on the command-line, then all Policies will be loaded with their
default configuration.

The format of the configuration file is a series of INI-style blocks that
contain key-value pairs separated by "=". Comments should start with "#" and
can be placed on a separate line or after the name-value pairs if you desire.

Default settings for perlcritic itself can be set B<before the first named
block.> For example, putting any or all of these at the top of your
F<.perlcriticrc> file will set the default value for the corresponding
command-line argument.

    severity  = 3                                     #Integer or named level
    only      = 1                                     #Zero or One
    force     = 0                                     #Zero or One
    verbose   = 4                                     #Integer or format spec
    top       = 50                                    #A positive integer
    theme     = (pbp + security) * bugs               #A theme expression
    include   = NamingConventions ClassHierarchies    #Space-delimited list
    exclude   = Variables  Modules::RequirePackage    #Space-delimited list

The remainder of the configuration file is a series of blocks like this:

    [Perl::Critic::Policy::Category::PolicyName]
    severity = 1
    set_themes = foo bar
    add_themes = baz
    arg1 = value1
    arg2 = value2

C<Perl::Critic::Policy::Category::PolicyName> is the full name of a module
that implements the policy.  The Policy modules distributed with Perl::Critic
have been grouped into categories according to the table of contents in Damian
Conway's book B<Perl Best Practices>. For brevity, you can omit the
C<'Perl::Critic::Policy'> part of the module name.

C<severity> is the level of importance you wish to assign to the Policy.  All
Policy modules are defined with a default severity value ranging from 1 (least
severe) to 5 (most severe).  However, you may disagree with the default
severity and choose to give it a higher or lower severity, based on your own
coding philosophy.  You can set the C<severity> to an integer from 1 to 5, or
use one of the equivalent names:

    SEVERITY NAME ...is equivalent to... SEVERITY NUMBER
    ----------------------------------------------------
    gentle                                             5
    stern                                              4
    harsh                                              3
    cruel                                              2
    brutal                                             1

C<set_themes> sets the theme for the Policy and overrides it's default theme.
The argument is a string of one or more whitespace-delimited alphanumeric
words.  Themes are case-insensitive.  See L<"POLICY THEMES"> for more
information.

C<add_themes> appends to the default themes for this Policy.  The argument is
a string of one or more whitespace-delimited words.  Themes are
case-insensitive.  See L<"POLICY THEMES"> for more information.

The remaining key-value pairs are configuration parameters that will be passed
into the constructor of that Policy.  The constructors for most Policy modules
do not support arguments, and those that do should have reasonable defaults.
See the documentation on the appropriate Policy module for more details.

Instead of redefining the severity for a given Policy, you can completely
disable a Policy by prepending a '-' to the name of the module in your
configuration file.  In this manner, the Policy will never be loaded,
regardless of the C<-severity> given on the command line.

A simple configuration might look like this:

    #--------------------------------------------------------------
    # I think these are really important, so always load them

    [TestingAndDebugging::RequireUseStrict]
    severity = 5

    [TestingAndDebugging::RequireUseWarnings]
    severity = 5

    #--------------------------------------------------------------
    # I think these are less important, so only load when asked

    [Variables::ProhibitPackageVars]
    severity = 2

    [ControlStructures::ProhibitPostfixControls]
    allow = if unless  # My custom configuration
    severity = cruel   # Same as "severity = 2"

    #--------------------------------------------------------------
    # Give these policies a custom theme.  I can activate just
    # these policies by saying "perlcritic -theme 'larry || curly'"

    [Modules::RequireFilenameMatchesPackage]
    add_themes = larry

    [TestingAndDebugging::RequireTestLables]
    add_themes = curly moe

    #--------------------------------------------------------------
    # I do not agree with these at all, so never load them

    [-NamingConventions::ProhibitMixedCaseVars]
    [-NamingConventions::ProhibitMixedCaseSubs]

    #--------------------------------------------------------------
    # For all other Policies, I accept the default severity,
    # so no additional configuration is required for them.

For additional configuration examples, see the F<perlcriticrc> file that is
included in this F<examples> directory of this distribution.

Damian Conway's own Perl::Critic configuration is also included in this
distribution as F<examples/perlcriticrc-conway>.

=head1 THE POLICIES

A large number of Policy modules are distributed with Perl::Critic.  They are
described briefly in the companion document L<Perl::Critic::PolicySummary> and
in more detail in the individual modules themselves.  Say C<"perlcritic -doc
PATTERN"> to see the perldoc for all Policy modules that match the regex
C<m/PATTERN/imx>

There are a number of distributions of additional policies on CPAN.  If
L<Perl::Critic> doesn't contain a policy that you want, some one may have
already written it.  Some of these can be found via L<Bundle::Perl::Critic>.

=head1 POLICY THEMES

Each Policy is defined with one or more "themes".  Themes can be used to
create arbitrary groups of Policies.  They are intended to provide an
alternative mechanism for selecting your preferred set of Policies.  For
example, you may wish disable a certain set of Policies when analyzing test
scripts.  Conversely, you may wish to enable only a specific subset of
Policies when analyzing modules.

The Policies that ship with Perl::Critic are have been divided into the
following themes.  This is just our attempt to provide some basic logical
groupings.  You are free to invent new themes that suit your needs.

    THEME             DESCRIPTION
    --------------------------------------------------------------------------
    core              All policies that ship with Perl::Critic
    pbp               Policies that come directly from "Perl Best Practices"
    bugs              Policies that that prevent or reveal bugs
    maintenance       Policies that affect the long-term health of the code
    cosmetic          Policies that only have a superficial effect
    complexity        Policies that specificaly relate to code complexity
    security          Policies that relate to security issues
    tests             Policies that are specific to test scripts

Say C<"perlcritic -list"> to get a listing of all available policies and the
themes that are associated with each one.  You can also change the theme for
any Policy in your F<.perlcriticrc> file.  See the L<"CONFIGURATION"> section
for more information about that.

Using the C<-theme> command-line option, you can create an arbitrarily complex
rule that determines which Policies to apply.  Precedence is the same as
regular Perl code, and you can use parens to enforce precedence as well.
Supported operators are:

   Operator    Altertative    Example
   ----------------------------------------------------------------------------
   &&          and            'pbp && core'
   ||          or             'pbp || (bugs && security)'
   !           not            'pbp && ! (portability || complexity)'

Theme names are case-insensitive.  If the C<-theme> is set to an empty string,
then it evaluates as true all Policies.

=head1 BENDING THE RULES

Perl::Critic takes a hard-line approach to your code: either you
comply or you don't.  In the real world, it is not always practical
(or even possible) to fully comply with coding standards.  In such
cases, it is wise to show that you are knowingly violating the
standards and that you have a Damn Good Reason (DGR) for doing so.

To help with those situations, you can direct Perl::Critic to ignore
certain lines or blocks of code by using pseudo-pragmas:

    require 'LegacyLibaray1.pl';  ## no critic
    require 'LegacyLibrary2.pl';  ## no critic

    for my $element (@list) {

        ## no critic

        $foo = "";               #Violates 'ProhibitEmptyQuotes'
        $barf = bar() if $foo;   #Violates 'ProhibitPostfixControls'
        #Some more evil code...

        ## use critic

        #Some good code...
        do_something($_);
    }

The C<"## no critic"> comments direct Perl::Critic to ignore the remaining
lines of code until the end of the current block, or until a C<"## use
critic"> comment is found (whichever comes first).  If the C<"## no critic">
comment is on the same line as a code statement, then only that line of code
is overlooked.  To direct perlcritic to ignore the C<"## no critic"> comments,
use the C<-force> option.

A bare C<"## no critic"> comment disables all the active Policies.  If you
wish to disable only specific Policies, add a list of Policy names as
arguments just as you would for the C<"no strict"> or C<"no warnings"> pragma.
For example, this would disable the C<ProhibitEmptyQuotes> and
C<ProhibitPostfixControls> policies until the end of the block or until the
next C<"## use critic"> comment (whichever comes first):

  ## no critic (EmptyQuotes, PostfixControls);

  # Now exempt from ValuesAndExpressions::ProhibitEmptyQuotes
  $foo = "";

  # Now exempt ControlStructures::ProhibitPostfixControls
  $barf = bar() if $foo;

  # Still subject to ValuesAndExpression::RequireNumberSeparators
  $long_int = 10000000000;

Since the Policy names are matched against the C<"## no critic"> arguments as
regular expressions, you can abbreviate the Policy names or disable an entire
family of Policies in one shot like this:

  ## no critic (NamingConventions)

  # Now exempt from NamingConventions::ProhibitMixedCaseVars
  my $camelHumpVar = 'foo';

  # Now exempt from NamingConventions::ProhibitMixedCaseSubs
  sub camelHumpSub {}

The argument list must be enclosed in parens and must contain one or more
comma-separated barewords (i.e. don't use quotes).  The C<"## no critic">
pragmas can be nested, and Policies named by an inner pragma will be disabled
along with those already disabled an outer pragma.

Some Policies like C<Subroutines::ProhibitExcessComplexity> apply to an entire
block of code.  In those cases, C<"## no critic"> must appear on the line
where the violation is reported.  For example:

  sub complicated_function {  ## no critic (ProhibitExcessComplexity)
      # Your code here...
  }

Some Policies like C<Documentation::RequirePodSections> apply to the entire
document, in which case violations are reported at line 1.  But if the file
requires a shebang line, it is impossible to put C<"## no critic"> on the
first line of the file.  This is a known limitation and it will be addressed
in a future release.  As a workaround, you can disable the affected policies
at the command-line or in your F<.perlcriticrc> file.  But beware that this
will affect the analysis of B<all> files.

Use this feature wisely.  C<"## no critic"> should be used in the smallest
possible scope, or only on individual lines of code. And you should always be
as specific as possible about which policies you want to disable (i.e. never
use a bare C<"## no critic">).  If Perl::Critic complains about your code, try
and find a compliant solution before resorting to this feature.

=head1 IMPORTANT CHANGES

Perl-Critic is evolving rapidly.  As such, some of the interfaces have changed
in ways that are not backward-compatible.  If you have been using an older
version of Perl-Critic and/or you have been developing custom Policy modules,
please read this section carefully.

=head2 VERSION 0.23

In version 0.23, the syntax for theme rules changed.  The mathematical
operators ( "*", "+", "-" ) are no longer supported.  You must use logical
operators instead ( "&&", "!", "||" ).  However the meanings of these
operators is effectively the same.  See L<"POLICY THEMES"> for more details.

=head2 VERSION 0.21

In version 0.21, we introduced the concept of policy "themes".  All you
existing custom Policies should still be compatible.  But to take advantage of
the theme feature, you should add a C<default_themes> method to your custom
Policy modules.  See L<Perl::Critic::DEVELOPER> for an up-to-date guide on
creating Policy modules.

=head2 VERSION 0.16

Starting in version 0.16, you can add a list Policy names as arguments to the
C<"## no critic"> pseudo-pragma.  This feature allows you to disable specific
policies.  So if you have been in the habit of adding additional words after
C<"no critic">, then those words might cause unexpected results.  If you want
to append other stuff to the C<"## no critic"> comment, then terminate the
pseudo-pragma with a semi-colon, and then start another comment.  For example:

  #This may not work as expected.
  $email = 'foo@bar.com';  ## no critic for literal '@'

  #This will work.
  $email = 'foo@bar.com';  ## no critic; #for literal '@'

  #This is even better.
  $email = 'foo@bar.com'; ## no critic (RequireInterpolation);

=head2 VERSION 0.14

Starting in version 0.14, the interface to L<Perl::Critic::Violation> changed.
This will also break any custom Policy modules that you might have written for
earlier modules.  See L<Perl::Critic::DEVELOPER> for an up-to-date guide on
creating Policy modules.

The notion of "priority" was also replaced with "severity" in version 0.14.
Consequently, the default behavior of Perl::Critic is to only load the most
"severe" Policy modules, rather than loading all of them.  This decision was
based on user-feedback suggesting that Perl-Critic should be less "critical"
for new users, and should steer them toward gradually increasing the
strictness as they adopt better coding practices.

=head2 VERSION 0.11

Starting in version 0.11, the internal mechanics of Perl-Critic were rewritten
so that only one traversal of the PPI document tree is required.
Unfortunately, this will break any custom Policy modules that you might have
written for earlier versions.  Converting your policies to work with the new
version is pretty easy and actually results in cleaner code.  See
L<Perl::Critic::DEVELOPER> for an up-to-date guide on creating Policy modules.

=head1 EDITOR INTEGRATION

For ease-of-use, C<perlcritic> can be integrated with your favorite text
editor.  The output-formatting capabilities of C<perlcritic> are specifically
intended for use with the "grep" or "compile" modes available in editors like
C<emacs> and C<vim>.  In these modes, you can run an arbitrary command and the
editor will parse the output into an interactive buffer that you can click on
and jump to the relevant line of code.

The Perl::Critic team thanks everyone who has helped integrate Perl-Critic
with their favorite editor.  Your contributions in particular have made
Perl-Critic a convenient and user-friendly tool for Perl developers of all
stripes.  We sincerely appreciate your hard work.

=head2 EMACS

Joshua ben Jore has authored a minor-mode for emacs that allows you to run
perlcritic on the current region or buffer.  You can run it on demand, or
configure it to run automatically when you save the buffer.  The output
appears in a hot-linked compiler buffer.  The code and installation
instructions can be found in the F<extras> directory inside this distribution.

=head2 VIM

Scott Peshak has published F<perlchecker.vim>, which is available at
L<http://www.vim.org/scripts/script.php?script_id=1731>.

=head2 gVIM

Fritz Mehner recently added support for C<perlcritic> to his fantastic gVIM
plugin.  In addition to providing a very Perlish IDE, Fritz's plugin enables
one-click access to C<perlcritic> and many other very useful utilities.  And
all is seamlessly integrated into the editor. See
L<http://lug.fh-swf.de/vim/vim-perl/screenshots-en.html> for complete details.

=head2 EPIC

EPIC is an open source Perl IDE based on the Eclipse platform.  Features
supported are syntax highlighting, on-the-fly syntax check, content assist,
perldoc support, source formatter, templating support and a Perl debugger.  Go
to L<http://e-p-i-c.sourceforge.net> for more information about EPIC.

The EPIC team is currently working on integration with Perl::Critic.  In the
meantime, you can use the L<criticism> pragma and EPIC will highlight
violations whenever it does a syntax check on your code.  I haven't tried this
myself, but other folks say it works.

=head2 BBEdit

Josh Clark has produced an excellent Perl-Critic plugin for BBEdit. A copy is
included in this distribution at F<extras/perl_critic_for_bbedit-1_0.zip>. See
L<http://beta.bigmedium.com/projects/bbedit-perl-critic/index.shtml> for
screenshots and additional installation info.  Apple users rejoice!

=head2 Komodo

Komodo is a proprietary IDE for Perl and several other dynamic languages.
Free trial copies of Komodo can be obtained from the ActiveState website at
L<http://www.activestate.com>. For instructions on integrating F<perlcritic>
with Komodo, see F<extras/KomodoIntegration.pod> in this distribution.

=head1 EXIT STATUS

If C<perlcritic> has any errors itself, exits with status == 1.  If there are
no errors, but C<perlcritic> finds Policy violations in your source code,
exits with status == 2.  If there were no errors and no violations were found,
exits with status == 0.

=head1 THE L<Perl::Critic> PHILOSOPHY

  Coding standards are deeply personal and highly subjective.  The
  goal of Perl::Critic is to help you write code that conforms with a
  set of best practices.  Our primary goal is not to dictate what
  those practices are, but rather, to implement the practices
  discovered by others.  Ultimately, you make the rules --
  Perl::Critic is merely a tool for encouraging consistency.  If there
  is a policy that you think is important or that we have overlooked,
  we would be very grateful for contributions, or you can simply load
  your own private set of policies into Perl::Critic.

=head1 EXTENDING THE CRITIC

The modular design of Perl::Critic is intended to facilitate the addition of
new Policies.  You'll need to have some understanding of L<PPI>, but most
Policy modules are pretty straightforward and only require about 20 lines of
code.  Please see the L<Perl::Critic::DEVELOPER> file included in this
distribution for a step-by-step demonstration of how to create new Policy
modules.

If you develop any new Policy modules, feel free to send them to C<<
<thaljef@cpan.org> >> and I'll be happy to put them into the Perl::Critic
distribution.  Or if you would like to work on the Perl::Critic project
directly, check out our repository at L<http://perlcritic.tigris.org>.  To
subscribe to our mailing list, send a message to C<<
<dev-subscribe@perlcritic.tigris.org> >>.

The Perl::Critic team is also available for hire.  If your organization has
its own coding standards, we can create custom Policies to enforce your local
guidelines.  Or if your code base is prone to a particular defect pattern, we
can design Policies that will help you catch those costly defects B<before>
they go into production.  To discuss your needs with the Perl::Critic team,
just contact C<< <thaljef@cpan.org> >>.

=head1 BUGS

Scrutinizing Perl code is hard for humans, let alone machines.  If you find
any bugs, particularly false-positives or false-negatives from a
Perl::Critic::Policy, please submit them to
L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Perl-Critic>.  Thanks.

Most policies will produce false-negatives if they cannot understand a
particular block of code.

=head1 CREDITS

Adam Kennedy - For creating L<PPI>, the heart and soul of L<Perl::Critic>.

Damian Conway - For writing B<Perl Best Practices>, finally :)

Chris Dolan - For contributing the best features and Policy modules.

Andy Lester - Wise sage and master of all-things-testing.

Elliot Shank - The self-proclaimed quality freak.

Giuseppe Maxia - For all the great ideas and positive encouragement.

and Sharon, my wife - For putting up with my all-night code sessions.

=head1 AUTHOR

Jeffrey Ryan Thalhammer <thaljef@cpan.org>

=head1 COPYRIGHT

Copyright (c) 2005-2007 Jeffrey Ryan Thalhammer.  All rights reserved.

This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.  The full text of this license can be found in
the LICENSE file included with this module.

=cut

##############################################################################
# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 78
#   indent-tabs-mode: nil
#   c-indentation-style: bsd
# End:
# ex: set ts=8 sts=4 sw=4 tw=78 ft=perl expandtab :
